<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Populate the Rebeginning</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-bar { padding: 10px; text-align: center; text-shadow: 1px 1px 2px black; pointer-events: auto; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);}
        p { margin: 5px 0 0; font-size: 12px; color: white; }

        /* TAB SYSTEM */
        #bottom-ui {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding-bottom: 20px;
        }

        #tabs {
            display: flex; justify-content: center; gap: 10px; margin-bottom: 5px;
        }
        .tab-btn {
            width: 24px; height: 24px; border-radius: 50%; background: #444; border: 2px solid #888;
            color: white; font-size: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .tab-btn.active { background: #FFD700; color: black; border-color: white; box-shadow: 0 0 5px #FFD700; }

        #action-bar {
            display: flex; justify-content: center; gap: 5px; padding: 5px;
            flex-wrap: wrap;
            min-height: 40px;
        }

        .action-btn {
            width: 50px; height: 50px;
            border-radius: 50%;
            border: 2px solid #555;
            background: #222;
            color: white;
            font-size: 19px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 3px rgba(0,0,0,0.5);
            position: relative;
        }
        .action-btn.active { border-color: #FFD700; transform: translateY(-3px); box-shadow: 0 0 8px #FFD700; background: #444; }
        .action-btn:active { transform: scale(0.95); }
        .label { font-size: 12px; position: absolute; bottom: -19px; width: 140%; left: -20%; text-align: center; text-shadow: 1px 1px 1px black; color: #ddd;}

        #mana-bar {
            width: 200px; height: 10px; background: #333; margin: 0 auto; border: 1px solid white; border-radius: 5px; overflow: hidden;
        }
        #mana-fill { width: 100%; height: 100%; background: #00BFFF; transition: width 0.2s; }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #FFD700; display: flex; align-items: center; justify-content: center;
            z-index: 100; font-size: 24px; font-weight: bold;
        }

        /* UNIT LIST */
        #unit-list {
            position: absolute;
            top: 70px;
            left: 0;
            width: 48px;
            bottom: 120px;
            overflow-y: auto;
            overflow-x: hidden;
            background: rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 2px;
            pointer-events: auto;
            z-index: 10;
            touch-action: pan-y;
        }
        #unit-list::-webkit-scrollbar { width: 3px; }
        #unit-list::-webkit-scrollbar-track { background: transparent; }
        #unit-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 1px; }

        .unit-item {
            width: 29px;
            height: 29px;
            background: #333;
            border: 1px solid #555;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 17px;
            cursor: pointer;
            flex-shrink: 0;
            position: relative;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .unit-item:active { transform: scale(0.9); }
        .unit-item.selected { border-color: #00FF00; box-shadow: 0 0 10px #00FF00; background: #444; }
        .unit-item.enemy { border-color: #FF0000; }
        .unit-item.enemy.selected { border-color: #FF4500; box-shadow: 0 0 10px #FF4500; }

        .hp-indicator {
            position: absolute;
            bottom: 2px; left: 10%; width: 80%; height: 2px; background: #555;
        }
        .hp-val { height: 100%; background: #00FF00; width: 100%; }
        .unit-item.enemy .hp-val { background: #FF0000; }

        /* RADIAL MENU CSS */
        #radial-container {
            position: relative;
            width: 72px; height: 72px;
            margin: 0 auto 5px auto;
            touch-action: none;
        }
        #main-icon {
            width: 62px; height: 62px;
            border-radius: 50%;
            background: #444;
            border: 2px solid #888;
            color: white;
            font-size: 26px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            position: relative;
            z-index: 20;
            box-shadow: 0 0 5px black;
        }
        #radial-options {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #radial-options.open { opacity: 1; pointer-events: auto; }
        .radial-option {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #666;
            color: white;
            font-size: 22px;
            display: flex; align-items: center; justify-content: center;
            position: absolute;
            top: 14px; left: 14px; /* Center relative to container */
            transition: transform 0.2s, background 0.2s;
            box-shadow: 0 0 3px black;
        }
        /* Positions: Basic(Left), Spells(Top), Build(Right) */
        .radial-option[data-tab="basic"] { transform: translate(-50px, -15px); }
        .radial-option[data-tab="spells"] { transform: translate(0, -65px); }
        .radial-option[data-tab="build"] { transform: translate(50px, -15px); }

        .radial-option.highlight { background: #FFD700; color: black; transform: scale(1.2) !important; z-index: 25; }
        /* Keep positions when highlighted */
        .radial-option[data-tab="basic"].highlight { transform: translate(-50px, -15px) scale(1.2); }
        .radial-option[data-tab="spells"].highlight { transform: translate(0, -65px) scale(1.2); }
        .radial-option[data-tab="build"].highlight { transform: translate(50px, -15px) scale(1.2); }

    </style>
</head>
<body>

<div id="loading">Generating World...</div>

<div id="ui-layer">
    <div id="unit-list"></div>
    <div id="top-bar">
        <div id="mana-bar"><div id="mana-fill"></div></div>
        <p>Mana: <span id="mana-text">100</span></p>
    </div>

    <div id="bottom-ui">
        <!-- Radial Menu Structure -->
        <div id="radial-container">
            <div id="main-icon">üë£</div>
            <div id="radial-options">
                <div class="radial-option" data-tab="basic">üë£</div>
                <div class="radial-option" data-tab="spells">‚ö°</div>
                <div class="radial-option" data-tab="build">üî®</div>
            </div>
        </div>
        <div id="btn-multiselect" class="tab-btn" onclick="toggleMultiSelect()" style="position:absolute; bottom:20px; right:20px;">‚äï</div>
        <div id="btn-unload" class="action-btn" onclick="unloadSelected()" style="position:absolute; bottom:20px; left:calc(50% + 60px); display:none; background:#444; border-color:#fff; z-index: 50;">‚¨áÔ∏è</div>
        
        <!-- Select Info / Mode -->
        <div id="menu-select" class="action-menu">
            <div id="action-bar" style="color:white; justify-content:center; padding-top:20px;">
                Select a unit
            </div>
        </div>

        <!-- Basic Unit Actions (Move) -->
        <div id="menu-basic" class="action-menu" style="display:none;">
            <div id="action-bar">
                <div class="action-btn" onclick="selectAction('move')" id="btn-move">üë£<span class="label">Walk</span></div>
            </div>
        </div>

        <!-- Spells Menu -->
        <div id="menu-spells" class="action-menu" style="display:none;">
            <div id="action-bar">
                <div class="action-btn" onclick="selectAction('blast')" id="btn-blast">üî•<span class="label">Fire (10)</span></div>
                <div class="action-btn" onclick="selectAction('lightning')" id="btn-lightning">‚ö°<span class="label">Lightning (30)</span></div>
                <div class="action-btn" onclick="selectAction('convert')" id="btn-convert">üôè<span class="label">Convert (10)</span></div>
                <div class="action-btn" onclick="selectAction('raise')" id="btn-raise">‚ñ≤<span class="label">Raise (5)</span></div>
                <div class="action-btn" onclick="selectAction('lower')" id="btn-lower">‚ñº<span class="label">Lower (5)</span></div>
                <div class="action-btn" onclick="selectAction('flatten')" id="btn-flatten">‚ûñ<span class="label">Flatten (10)</span></div>
                <div class="action-btn" onclick="selectAction('landbridge')" id="btn-landbridge">üåâ<span class="label">Bridge (20)</span></div>
                <div class="action-btn" onclick="selectAction('swamp')" id="btn-swamp">üå´Ô∏è<span class="label">Swamp (15)</span></div>
                <div class="action-btn" onclick="selectAction('invisibility')" id="btn-invisibility">üëª<span class="label">Invis (20)</span></div>
                <div class="action-btn" onclick="selectAction('shield')" id="btn-shield">üõ°Ô∏è<span class="label">Shield (20)</span></div>
                <div class="action-btn" onclick="selectAction('hypnotise')" id="btn-hypnotise">üåÄ<span class="label">Hypno (50)</span></div>
                <div class="action-btn" onclick="selectAction('swarm')" id="btn-swarm">üêù<span class="label">Swarm (20)</span></div>
                <div class="action-btn" onclick="selectAction('tornado')" id="btn-tornado">üå™Ô∏è<span class="label">Tornado (60)</span></div>
                <div class="action-btn" onclick="selectAction('firestorm')" id="btn-firestorm">‚òÑÔ∏è<span class="label">Storm (80)</span></div>
                <div class="action-btn" onclick="selectAction('volcano')" id="btn-volcano">üåã<span class="label">Volcano (40)</span></div>
                <div class="action-btn" onclick="selectAction('heal')" id="btn-heal">üíñ<span class="label">Heal (10)</span></div>
            </div>
        </div>

        <!-- Build Menu -->
        <div id="menu-build" class="action-menu" style="display:none;">
            <div id="action-bar">
                <div class="action-btn" onclick="selectAction('build_hut')" id="btn-build_hut">üè†<span class="label">Hut (15)</span></div>
                <div class="action-btn" onclick="selectAction('build_tower')" id="btn-build_tower">üóº<span class="label">Tower (20)</span></div>
                <div class="action-btn" onclick="selectAction('build_warrior')" id="btn-build_warrior">‚öîÔ∏è<span class="label">Barracks (30)</span></div>
                <div class="action-btn" onclick="selectAction('build_fire')" id="btn-build_fire">üî•<span class="label">Temple (40)</span></div>
                <div class="action-btn" onclick="selectAction('build_spy')" id="btn-build_spy">üåô<span class="label">Spy (40)</span></div>
                <div class="action-btn" onclick="selectAction('build_shipyard')" id="btn-build_shipyard">‚öì<span class="label">Shipyard (50)</span></div>
                <div class="action-btn" onclick="selectAction('build_airship')" id="btn-build_airship">üéà<span class="label">Airship (25)</span></div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
    // --- CONFIGURATION ---
    const CHUNK_SIZE = 40; 
    const CHUNK_RES = 150;
    const RENDER_DISTANCE = 3;
    const NOISE_SCALE = 0.02;
    const MIN_ZOOM = 3;
    const MAX_ZOOM = 70;

    const COLORS = {
        water: 0x1E90FF, sand: 0xEEDC82, grass: 0x228B22, rock: 0x696969, snow: 0xFFFFFF,
        lava: 0xCF1020, skin: 0xD2B48C, shirt_wild: 0x8B4513, shirt_shaman: 0xFF4500,
        wood: 0x8B4513, straw: 0xDAA520, stone: 0x808080, red: 0x8B0000, yellow: 0xFFD700, blue: 0x4169E1
    };

    const BUILDING_COSTS = { hut: 15, tower: 20, warrior: 30, fire: 40, spy: 40, shipyard: 50 };

    // --- AUDIO SYSTEM ---
    const SoundManager = {
        ctx: null,
        init: function() {
            if (this.ctx) return;
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                if(window.AudioContext) {
                    this.ctx = new AudioContext();
                } else {
                    console.warn("WebAudio not supported");
                }
            } catch(e) {
                console.warn("AudioContext creation failed:", e);
            }
        },
        playTone: function(freq, type, duration, vol=0.1) {
            if(!this.ctx) this.init();
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playNoise: function(duration, vol=0.1) {
            if(!this.ctx) this.init();
            if(!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },
        playSound: function(name) {
            if(!this.ctx) this.init();
            if(!this.ctx) return;
            if(this.ctx.state === 'suspended') this.ctx.resume();

            switch(name) {
                case 'attack':
                    this.playNoise(0.1, 0.2);
                    this.playTone(150, 'square', 0.1, 0.1);
                    break;
                case 'fireball':
                    this.playTone(400, 'sine', 0.3, 0.1);
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                    break;
                case 'explosion':
                    this.playNoise(0.5, 0.5);
                    this.playTone(50, 'sawtooth', 0.5, 0.3);
                    break;
                case 'magic':
                    this.playTone(800, 'sine', 0.5, 0.1);
                    this.playTone(1200, 'sine', 0.5, 0.05);
                    break;
                case 'construct':
                     this.playTone(200, 'square', 0.1, 0.1);
                     setTimeout(()=>this.playTone(200, 'square', 0.1, 0.1), 200);
                     break;
                case 'rumble':
                    this.playTone(80, 'sawtooth', 0.5, 0.2);
                    break;
            }
        }
    };

    // --- GLOBAL SYSTEMS ---
    let scene, camera, renderer, raycaster;
    let clock;
    let simplex;
    
    // Game State
    const chunks = {}; 
    const terrainMods = new Map();
    const units = []; window.units = units;
    const particles = [];
    const projectiles = [];
    const buildings = []; window.buildings = buildings;
    const activeEffects = [];
    
    let shaman;
    let selectedUnits = [];
    let cameraLookAt;
    let viewScale = 35; 
    let currentAction = 'select';
    let mana = 100;
    
    // Input
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let tapStart = { x: 0, y: 0 };
    let pinchStartDist = 0;
    let pinchStartScale = 35;
    let pinchStartAngle = 0;
    let rotateStartCamera = 0;
    let cameraRotation = Math.PI / 4;
    let multiSelectMode = false;

    window.toggleMultiSelect = function() {
        multiSelectMode = !multiSelectMode;
        const btn = document.getElementById('btn-multiselect');
        if(multiSelectMode) {
             btn.classList.add('active');
             btn.style.boxShadow = '0 0 10px #00FF00';
             btn.style.borderColor = '#00FF00';
             btn.style.color = '#00FF00';
        } else {
             btn.classList.remove('active');
             btn.style.boxShadow = '';
             btn.style.borderColor = '#888';
             btn.style.color = 'white';
        }
    }

    // --- HEIGHT LOGIC ---
    function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }

    function getBaseHeight(x, z) {
        if (!simplex) return 0;
        let y = 0;
        y += simplex.noise2D(x * NOISE_SCALE, z * NOISE_SCALE) * 12;
        y += simplex.noise2D(x * NOISE_SCALE * 2, z * NOISE_SCALE * 2) * 4;
        y += simplex.noise2D(x * NOISE_SCALE * 4, z * NOISE_SCALE * 4) * 1.5; 

        // Continuous smoothing
        if (y < 2.0) y -= (2.0 - y) * 0.2;
        if (y > 8.0) y += (y - 8.0) * 0.5;
        return y;
    }

    function getTerrainMod(x, z) {
        const x1 = Math.floor(x);
        const z1 = Math.floor(z);
        const x2 = x1 + 1;
        const z2 = z1 + 1;

        const fx = x - x1;
        const fz = z - z1;

        const v11 = terrainMods.get(`${x1},${z1}`) || 0;
        const v21 = terrainMods.get(`${x2},${z1}`) || 0;
        const v12 = terrainMods.get(`${x1},${z2}`) || 0;
        const v22 = terrainMods.get(`${x2},${z2}`) || 0;

        // Bilinear interpolation
        const i1 = v11 * (1 - fx) + v21 * fx;
        const i2 = v12 * (1 - fx) + v22 * fx;
        return i1 * (1 - fz) + i2 * fz;
    }

    function getHeight(x, z) {
        let h = getBaseHeight(x, z);
        h += getTerrainMod(x, z);
        return h;
    }

    // --- INITIALIZATION ---
    window.onload = () => setTimeout(init, 100);

    function init() {
        try {
            document.getElementById('loading').style.display = 'none';

            if(typeof SimplexNoise !== 'undefined') {
                simplex = new SimplexNoise(mulberry32(12345));
            } else {
                console.warn("SimplexNoise missing, using fallback");
                simplex = { noise2D: (x,y) => Math.sin(x)*Math.cos(y) }; // Fallback
            }

            // Init THREE globals
            clock = new THREE.Clock();
            cameraLookAt = new THREE.Vector3(0, 0, 0);
            chunkTerrainMat = new THREE.MeshLambertMaterial({ vertexColors: true, flatShading: false });
            chunkWaterGeo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES/2, CHUNK_RES/2);

            const waterVertexShader = `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vec3 pos = position;

                    float height = 0.0;
                    // Primary wave
                    height += sin(worldPosition.x * 0.5 + time) * 0.15;
                    height += sin(worldPosition.z * 0.4 + time) * 0.15;

                    // Secondary detail wave
                    height += sin(worldPosition.x * 1.5 + time * 1.5) * 0.05;
                    height += sin(worldPosition.z * 1.2 + time * 1.3) * 0.05;

                    pos.z += height;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;
            const waterFragmentShader = `
                uniform vec3 color;
                varying vec2 vUv;
                void main() {
                    gl_FragColor = vec4(color, 0.6);
                }
            `;
            chunkWaterMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(COLORS.water) }
                },
                vertexShader: waterVertexShader,
                fragmentShader: waterFragmentShader,
                transparent: true,
                side: THREE.DoubleSide
            });

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -500, 1000);
            updateCameraZoom();

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.7);
            sun.position.set(50, 100, 40);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
            sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
            sun.shadow.bias = -0.0005;
            scene.add(sun);

            raycaster = new THREE.Raycaster();

            findSafeSpawnAndStart();

            const c = renderer.domElement;
            c.addEventListener('mousedown', onPointerDown);
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mouseup', onPointerUp);
            c.addEventListener('touchstart', onTouchStart, {passive: false});
            window.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('touchend', onPointerUp);
            c.addEventListener('wheel', onWheel, {passive: false});
            window.addEventListener('resize', onResize);

            setupRadialMenu();
            // Default to Basic/Move
            switchTab('basic');
            selectAction('move');

            animate();
        } catch(e) {
            console.error("Init failed:", e);
            alert("Game failed to start: " + e.message);
        }
    }

    // --- UI SYSTEM ---
    function setupRadialMenu() {
        const btn = document.getElementById('main-icon');
        const container = document.getElementById('radial-container');
        const options = document.getElementById('radial-options');
        let isHolding = false;
        let holdTimer = null;

        const startHold = (e) => {
            isHolding = true;
            options.classList.add('open');
            // Prevent default?
        };

        const moveHold = (e) => {
            if(!isHolding) return;
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;

            // Check overlap
            document.querySelectorAll('.radial-option').forEach(opt => {
                const rect = opt.getBoundingClientRect();
                if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                    opt.classList.add('highlight');
                } else {
                    opt.classList.remove('highlight');
                }
            });
        };

        const endHold = (e) => {
            if(!isHolding) return;
            isHolding = false;
            options.classList.remove('open');

            let selected = null;
            const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const y = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

            // Prioritize already highlighted
            document.querySelectorAll('.radial-option').forEach(opt => {
                if(opt.classList.contains('highlight')) {
                    selected = opt.getAttribute('data-tab');
                    opt.classList.remove('highlight');
                }
            });

            // If not strictly highlighted, check distance to icons for forgiving selection (Drop at icon)
            if(!selected) {
                let closestDist = 9999;
                let closestTab = null;
                document.querySelectorAll('.radial-option').forEach(opt => {
                    const rect = opt.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.sqrt((x-cx)**2 + (y-cy)**2);
                    if(dist < 40 && dist < closestDist) { // 40px radius forgiveness
                        closestDist = dist;
                        closestTab = opt.getAttribute('data-tab');
                    }
                });
                if(closestTab) selected = closestTab;
            }

            if(selected) {
                switchTab(selected);
            } else {
                // Walking is default: if dropped anywhere else (center or void), revert to basic/move
                switchTab('basic');
                selectAction('move');
            }
        };

        btn.addEventListener('mousedown', startHold);
        window.addEventListener('mousemove', moveHold);
        window.addEventListener('mouseup', endHold);

        btn.addEventListener('touchstart', (e) => { e.preventDefault(); startHold(e); }, {passive:false});
        window.addEventListener('touchmove', moveHold, {passive:false});
        window.addEventListener('touchend', endHold);
    }

    window.switchTab = function(tab) {
        // If switching to select tab, set action to select
        if(tab === 'select') {
            currentAction = 'select';
            document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        }
        // If switching to basic tab, default to move
        if(tab === 'basic') {
            selectAction('move');
        }

        // Update Main Icon
        const mainIcon = document.getElementById('main-icon');
        if(tab === 'basic' || tab === 'select') mainIcon.innerHTML = 'üë£';
        else if(tab === 'spells') mainIcon.innerHTML = '‚ö°';
        else if(tab === 'build') mainIcon.innerHTML = 'üî®';

        document.querySelectorAll('.action-menu').forEach(m => m.style.display = 'none');
        const menu = document.getElementById(`menu-${tab}`);
        if(menu) menu.style.display = 'block';
    }

    window.selectAction = function(action) {
        currentAction = action;
        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById(`btn-${action}`);
        if(btn) btn.classList.add('active');
    }

    window.unloadSelected = function() {
        if(selectedUnits.length === 1 && selectedUnits[0].type === 'airship') {
            selectedUnits[0].unload();
        }
    }

    const UNIT_ICONS = {
        'wild': 'üòê',
        'warrior': '‚öîÔ∏è',
        'firewarrior': 'üî•',
        'shaman': '‚ö°',
        'spy': 'üïµÔ∏è'
    };

    let lastAliveCount = -1;

    function updateUnitList() {
        const list = document.getElementById('unit-list');
        list.innerHTML = '';

        // Sort: Shaman first, then Player units, then Enemy units
        const sortedUnits = [...units].sort((a,b) => {
            if(a.isShaman) return -1;
            if(b.isShaman) return 1;
            if(a.faction !== b.faction) return a.faction - b.faction;
            return 0;
        });

        sortedUnits.forEach(u => {
            if(u.state === 'dead') return;

            const item = document.createElement('div');
            item.className = 'unit-item';
            if(u.faction === 1) item.classList.add('enemy');
            if(selectedUnits.includes(u)) item.classList.add('selected');

            const icon = UNIT_ICONS[u.type] || '?';
            item.innerText = icon;

            // HP Bar
            const hpDiv = document.createElement('div');
            hpDiv.className = 'hp-indicator';
            const hpVal = document.createElement('div');
            hpVal.className = 'hp-val';
            hpVal.style.width = (u.hp / u.maxHp * 100) + '%';
            hpDiv.appendChild(hpVal);
            item.appendChild(hpDiv);

            item.onclick = (e) => {
                e.stopPropagation();

                if(u.faction === 0) {
                     if(multiSelectMode) {
                         if(selectedUnits.includes(u)) {
                             selectedUnits = selectedUnits.filter(x => x !== u);
                             u.selectRing.visible = false;
                         } else {
                             selectedUnits.push(u);
                             u.selectRing.visible = true;
                         }
                     } else {
                         selectedUnits.forEach(x => x.selectRing.visible = false);
                         selectedUnits = [u];
                         u.selectRing.visible = true;
                     }
                     updateContextMenus();
                }
                updateUnitListSelection();
            };

            item.ondblclick = (e) => {
                e.stopPropagation();
                cameraLookAt.copy(u.mesh.position);
            };

            u.listItem = item;
            u.hpValItem = hpVal;
            list.appendChild(item);
        });
    }

    function updateUnitListSelection() {
        units.forEach(u => {
            if(u.listItem) {
                if(selectedUnits.includes(u)) u.listItem.classList.add('selected');
                else u.listItem.classList.remove('selected');

                if(u.hpValItem) u.hpValItem.style.width = Math.max(0, (u.hp / u.maxHp * 100)) + '%';
            }
        });
    }

    function updateContextMenus() {
        const hasShaman = selectedUnits.some(u => u.isShaman);
        const hasBrave = selectedUnits.some(u => u.type === 'wild');
        const hasSelection = selectedUnits.length > 0;

        const hasAirship = selectedUnits.length === 1 && selectedUnits[0].type === 'airship';


        // Unload Button
        const unloadBtn = document.getElementById('btn-unload');
        if(unloadBtn) unloadBtn.style.display = (hasAirship && selectedUnits[0].passengers.length > 0) ? 'flex' : 'none';

        // Auto-switch tabs if needed
        if(hasSelection) {
            if(hasShaman) switchTab('spells');
            else if(hasBrave) switchTab('build');
            else switchTab('basic');
        } else {
            switchTab('select');
        }
    }

    // --- SPELL HELPERS ---
    window.castLandbridge = function(caster, x, z) {
        if (!caster || !caster.mesh) return;
        const start = caster.mesh.position.clone();
        const targetH = getHeight(start.x, start.z);
        const dist = Math.sqrt((x - start.x)**2 + (z - start.z)**2);
        const steps = Math.ceil(dist);
        const dirX = (x - start.x) / dist;
        const dirZ = (z - start.z) / dist;

        const allMods = new Set();
        const r = 2; // Radius 2 for width 4

        for(let i=0; i<=steps; i++) {
            const px = start.x + dirX * i;
            const pz = start.z + dirZ * i;

            for(let ix = Math.floor(px - r); ix <= Math.ceil(px + r); ix++) {
                for(let iz = Math.floor(pz - r); iz <= Math.ceil(pz + r); iz++) {
                    if((ix - px)**2 + (iz - pz)**2 <= r*r) {
                        const key = `${ix},${iz}`;
                        const base = getBaseHeight(ix, iz);
                        terrainMods.set(key, targetH - base);
                        const cx = Math.round(ix / CHUNK_SIZE);
                        const cz = Math.round(iz / CHUNK_SIZE);
                        allMods.add(`${cx},${cz}`);
                    }
                }
            }
        }

        // Building collapse check
        buildings.forEach(b => {
            const groundH = getHeight(b.mesh.position.x, b.mesh.position.z);
            if(Math.abs(groundH - b.mesh.position.y) > 1.0) {
                b.takeDamage(100);
            }
        });

        updateChunks(true, allMods);
        SoundManager.playSound('rumble');
    }

    // --- ACTIONS ---
    function performAction(x, z) {
        if(currentAction === 'move') {
            if(selectedUnits.length > 0) {
                selectedUnits.forEach(u => {
                    u.goto(x, z);
                    u.attackTarget = null;
                });
                spawnPulse(x, getHeight(x, z), z, 0xFFFFFF);
            }
            return;
        }

        // Prevent building on water
        if (currentAction.startsWith('build_') && getHeight(x, z) < 2.0) return;

        // Prevent building if no brave nearby
        if (currentAction.startsWith('build_') && !isBraveNearby(0, x, z, 10)) return;

        const costs = { 
            blast: 10, lightning: 30, convert: 10, raise: 5, lower: 5, flatten: 10, landbridge: 20,
            swamp: 15, invisibility: 20, shield: 20, hypnotise: 50, swarm: 20, tornado: 60, firestorm: 80, volcano: 40, heal: 10,
            build_hut: BUILDING_COSTS.hut, build_tower: BUILDING_COSTS.tower, build_warrior: BUILDING_COSTS.warrior,
            build_fire: BUILDING_COSTS.fire, build_spy: BUILDING_COSTS.spy, build_shipyard: BUILDING_COSTS.shipyard, build_airship: 25
        };
        const cost = costs[currentAction];
        if (cost === undefined || isNaN(cost)) return;
        if (mana < cost) return;
        mana -= cost;
        updateUI();

        if (currentAction === 'blast') {
            const startPos = shaman.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            const h = getHeight(x, z);
            const targetPos = new THREE.Vector3(x, h, z);
            projectiles.push(new Fireball(startPos, targetPos, 0));
            SoundManager.playSound('fireball');
            
            const dx = targetPos.x - shaman.mesh.position.x;
            const dz = targetPos.z - shaman.mesh.position.z;
            shaman.mesh.rotation.y = Math.atan2(dx, dz);
        }
        else if (currentAction === 'raise') {
            const mods = modifyTerrain(x, z, 5, 2.0);
            updateChunks(true, mods);
            spawnExplosion(x, getHeight(x, z), z, 0x00FF00, 10);
            SoundManager.playSound('rumble');
        }
        else if (currentAction === 'lower') {
            const mods = modifyTerrain(x, z, 5, -2.0);
            updateChunks(true, mods);
            spawnExplosion(x, getHeight(x, z), z, 0x0000FF, 10);
            SoundManager.playSound('rumble');
        }
        else if (currentAction === 'volcano') {
            createVolcano(x, z);
            SoundManager.playSound('explosion');
        }
        else if (currentAction === 'heal') {
            SoundManager.playSound('magic');
            spawnPulse(x, getHeight(x, z), z, 0xFF69B4);
            units.forEach(u => {
                if(u.faction === 0 && u.state !== 'dead') {
                    const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                    if(dist < 8) {
                        u.hp = u.maxHp;
                        u.hpBar.scale.x = 1.0;
                        spawnHealing(u.mesh.position.x, u.mesh.position.y + 2, u.mesh.position.z);
                    }
                }
            });
        }
        else if (currentAction === 'tornado') {
            activeEffects.push(new Tornado(x, z));
        }
        else if (currentAction === 'swarm') {
            activeEffects.push(new Swarm(x, z));
            SoundManager.playSound('magic');
        }
        else if (currentAction === 'firestorm') {
            activeEffects.push(new Firestorm(x, z, 0));
        }
        else if (currentAction === 'convert') {
            SoundManager.playSound('magic');
            spawnPulse(x, getHeight(x, z), z, 0x0000FF);
            units.forEach(u => {
                if(u.type === 'wild' && u.faction !== 0) {
                     const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                     if(dist < 10) {
                         u.faction = 0;
                         u.mesh.traverse(c => {
                             if(c.material && c.material.color.getHex() === COLORS.red) {
                                 c.material.color.setHex(COLORS.blue);
                             }
                         });
                         // Update HP Bar color
                         u.hpBar.material.color.setHex(0x00FF00);
                         spawnPulse(u.mesh.position.x, u.mesh.position.y+2, u.mesh.position.z, 0x0000FF);
                     }
                }
            });
        }
        else if (currentAction === 'shield') {
            SoundManager.playSound('magic');
            spawnPulse(x, getHeight(x, z), z, 0x00FFFF);
            units.forEach(u => {
                if(u.faction === 0) {
                    const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                    if(dist < 8) {
                        u.setShield(true);
                        setTimeout(() => u.setShield(false), 20000); // 20s
                    }
                }
            });
        }
        else if (currentAction === 'invisibility') {
            SoundManager.playSound('magic');
            units.forEach(u => {
                if(u.faction === 0) {
                    const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                    if(dist < 8) {
                        u.setInvisibility(true);
                        setTimeout(() => u.setInvisibility(false), 30000); // 30s
                    }
                }
            });
        }
        else if (currentAction === 'hypnotise') {
            SoundManager.playSound('magic');
            spawnPulse(x, getHeight(x, z), z, 0xFF00FF);
            units.forEach(u => {
                if(u.faction === 1 && !u.isShaman) {
                     const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                     if(dist < 8) {
                         u.faction = 0;
                         u.mesh.traverse(c => {
                             if(c.material && c.material.color.getHex() === COLORS.red) {
                                 c.material.color.setHex(COLORS.blue);
                             }
                         });
                         u.hpBar.material.color.setHex(0x00FF00);
                         u.state = 'idle'; u.attackTarget = null;
                         spawnPulse(u.mesh.position.x, u.mesh.position.y+2, u.mesh.position.z, 0xFF00FF);
                     }
                }
            });
        }
        else if (currentAction === 'flatten') {
            // Flatten to average
            let totalH = 0; let count = 0;
            const r = 5;
            for(let ix = Math.floor(x - r); ix <= Math.ceil(x + r); ix++) {
                for(let iz = Math.floor(z - r); iz <= Math.ceil(z + r); iz++) {
                    if((ix-x)**2 + (iz-z)**2 <= r*r) {
                        totalH += getHeight(ix, iz); count++;
                    }
                }
            }
            if(count > 0) {
                const avg = totalH / count;
                const modifiedChunks = new Set();
                for(let ix = Math.floor(x - r); ix <= Math.ceil(x + r); ix++) {
                    for(let iz = Math.floor(z - r); iz <= Math.ceil(z + r); iz++) {
                         if((ix-x)**2 + (iz-z)**2 <= r*r) {
                            const current = getHeight(ix, iz);
                            const key = `${ix},${iz}`;
                            const mod = terrainMods.get(key) || 0;
                            terrainMods.set(key, mod + (avg - current));
                            const cx = Math.round(ix / CHUNK_SIZE);
                            const cz = Math.round(iz / CHUNK_SIZE);
                            modifiedChunks.add(`${cx},${cz}`);
                         }
                    }
                }
                updateChunks(true, modifiedChunks);
                SoundManager.playSound('rumble');
            }
        }
        else if (currentAction === 'landbridge') {
            castLandbridge(shaman, x, z);
        }
        else if (currentAction === 'lightning') {
            SoundManager.playSound('explosion');
            // Visual Line
            const geo = new THREE.CylinderGeometry(0.5, 0.1, 30, 8);
            const mat = new THREE.MeshBasicMaterial({color: 0xFFFFFF, transparent: true, opacity: 0.8});
            const bolt = new THREE.Mesh(geo, mat);
            bolt.position.set(x, getHeight(x,z) + 15, z);
            scene.add(bolt);
            setTimeout(() => scene.remove(bolt), 100);
            spawnExplosion(x, getHeight(x,z), z, 0xFFFFFF, 20);

            // Damage
            let hit = false;
            burnTreesAt(x, z, 5); // Burn trees
            units.forEach(u => {
                 const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                 if(dist < 4) {
                     u.takeDamage(1000);
                     hit = true;
                 }
            });
            buildings.forEach(b => {
                 const dist = b.mesh.position.distanceTo(new THREE.Vector3(x, b.mesh.position.y, z));
                 if(dist < 4) {
                     b.takeDamage(500);
                     hit = true;
                 }
            });
        }
        else if (currentAction === 'build_airship') {
            // Build Airship
            // Find nearest shipyard
            let nearest = null; let minD = 50;
            buildings.forEach(b => {
                if(b.type === 'shipyard' && b.faction === 0 && !b.underConstruction) {
                    const d = Math.sqrt((b.mesh.position.x - x)**2 + (b.mesh.position.z - z)**2);
                    if(d < minD) { minD = d; nearest = b; }
                }
            });

            if(nearest) {
                 const safe = findNearestLand(x, z);
                 const h = getHeight(safe.x, safe.z);
                 const airship = new Humanoid(0, 'airship', safe.x, safe.z);
                 // Airship height override
                 airship.mesh.position.y = Math.max(h, 10);
                 units.push(airship);
                 spawnPulse(x, h, z, 0xFFFFFF);
                 SoundManager.playSound('construct');
            } else {
                 // No shipyard nearby
            }
        }
        else if (currentAction === 'unload') {
            if(selectedUnits.length === 1 && selectedUnits[0].type === 'airship') {
                selectedUnits[0].unload();
            }
        }
        else if (currentAction.startsWith('build_')) {
            const type = currentAction.replace('build_', '');
            createBuilding(type, x, z);
        }
    }

    // --- BUILDING SYSTEM ---
    function createBuilding(type, x, z, faction = 0, autoUpdate = true) {
        if(getHeight(x, z) < 2.0) return;

        SoundManager.playSound('construct');
        const baseH = getHeight(x, z);
        const radius = 3;
        
        // Auto-Leveling
        const modifiedChunks = new Set();
        for(let ix = Math.floor(x - radius); ix <= Math.ceil(x + radius); ix++) {
            for(let iz = Math.floor(z - radius); iz <= Math.ceil(z + radius); iz++) {
                const dist = Math.sqrt((ix-x)**2 + (iz-z)**2);
                if(dist <= radius) {
                    const key = `${ix},${iz}`;
                    const naturalH = getBaseHeight(ix, iz);
                    const targetMod = baseH - naturalH;
                    terrainMods.set(key, targetMod); 
                    const cx = Math.round(ix / CHUNK_SIZE);
                    const cz = Math.round(iz / CHUNK_SIZE);
                    modifiedChunks.add(`${cx},${cz}`);
                }
            }
        }
        if(autoUpdate) updateChunks(true, modifiedChunks);

        const group = new THREE.Group();
        group.position.set(x, baseH, z);
        
        let mesh, maxHp;
        if (type === 'hut') { mesh = buildHut(); maxHp = 100; }
        else if (type === 'tower') { mesh = buildTower(); maxHp = 150; }
        else if (type === 'warrior') { mesh = buildBarracks(); maxHp = 250; }
        else if (type === 'fire') { mesh = buildFireTemple(); maxHp = 300; }
        else if (type === 'spy') { mesh = buildSpyHut(); maxHp = 200; }
        else if (type === 'shipyard') { mesh = buildShipyard(); maxHp = 350; }
        
        if(mesh) {
            group.add(mesh);
            
            // HP Bar for Building
            const hpGroup = new THREE.Group();
            hpGroup.position.set(0, 5, 0); // High above the building
            const bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 0.3), new THREE.MeshBasicMaterial({color: 0x880000}));
            hpGroup.add(bgMesh);
            const fgGeo = new THREE.PlaneGeometry(2.0, 0.3); fgGeo.translate(1.0, 0, 0); 
            const hpBar = new THREE.Mesh(fgGeo, new THREE.MeshBasicMaterial({color: 0x00FF00}));
            hpBar.position.x = -1.0;
            hpGroup.add(hpBar);
            group.add(hpGroup);

            scene.add(group);
            
            // Construction logic
            const buildTime = BUILDING_COSTS[type] || 5; // Default 5s if not found
            mesh.scale.y = 0.01; // Start flat

            const building = { 
                mesh: group, 
                visualMesh: mesh,
                hpBar: hpBar,
                hpGroup: hpGroup,
                type: type, 
                faction: faction,
                hp: maxHp, 
                maxHp: maxHp,
                constructionTimer: buildTime,
                totalBuildTime: buildTime,
                underConstruction: true,
                takeDamage: function(amount) {
                    this.hp -= amount;
                    this.hpBar.scale.x = Math.max(0, this.hp / this.maxHp);
                    spawnPulse(this.mesh.position.x, this.mesh.position.y + 2, this.mesh.position.z, 0xFF4500);
                    if(this.hp <= 0) {
                        this.destroy();
                    }
                },
                destroy: function() {
                    this.dead = true;
                    scene.remove(this.mesh);
                    spawnExplosion(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, COLORS.wood, 20);
                    SoundManager.playSound('explosion');
                },
                update: function(dt) {
                    this.hpGroup.lookAt(camera.position);

                    if(this.underConstruction) {
                        this.constructionTimer -= dt;
                        const progress = 1.0 - (this.constructionTimer / this.totalBuildTime);
                        this.visualMesh.scale.y = Math.max(0.01, progress);

                        if(this.constructionTimer <= 0) {
                            this.underConstruction = false;
                            this.visualMesh.scale.y = 1.0;
                            spawnExplosion(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, 0xFFFFFF, 10);

                            // On Complete Logic
                            if(this.type === 'hut') {
                                // Spawn initial brave
                                const safe = findNearestLand(this.mesh.position.x + 2, this.mesh.position.z + 2, 10);
                                const u = new Humanoid(this.faction, 'wild', safe.x, safe.z);
                                units.push(u);
                                spawnPulse(u.mesh.position.x, u.mesh.position.y, u.mesh.position.z, 0xFFFFFF);
                            }
                        }
                        return; // Skip other updates while building
                    }

                    if(this.training) {
                        this.trainTimer -= dt;
                        if(this.trainTimer <= 0) {
                            this.training = false;
                            const safe = findNearestLand(this.mesh.position.x + 2, this.mesh.position.z + 2, 10);
                            const u = new Humanoid(this.trainFaction, this.trainType, safe.x, safe.z);
                            units.push(u);
                            spawnPulse(u.mesh.position.x, u.mesh.position.y, u.mesh.position.z, 0xFFD700);
                        }
                    }
                }
            };
            
            buildings.push(building);
            spawnExplosion(x, baseH, z, 0xFFD700, 15);
        }
    }

    // --- BUILDING MODELS ---
    function buildHut() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.4, 1.5, 8), new THREE.MeshLambertMaterial({color: COLORS.wood})); base.position.y = 0.75; base.castShadow = true; g.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.8, 1.5, 8), new THREE.MeshLambertMaterial({color: COLORS.straw})); roof.position.y = 1.5 + 0.75; roof.castShadow = true; g.add(roof);
        const door = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.2), new THREE.MeshLambertMaterial({color: 0x220000})); door.position.set(0, 0.5, 1.2); g.add(door);
        return g;
    }
    function buildTower() {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1.0, 4, 6), new THREE.MeshLambertMaterial({color: COLORS.wood})); body.position.y = 2; body.castShadow = true; g.add(body);
        const plat = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.2, 0.5, 6), new THREE.MeshLambertMaterial({color: COLORS.wood})); plat.position.y = 3.8; g.add(plat);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1.0, 6), new THREE.MeshLambertMaterial({color: COLORS.straw})); roof.position.y = 4.5; g.add(roof);
        return g;
    }
    function buildBarracks() {
        const g = new THREE.Group();
        const walls = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 2), new THREE.MeshLambertMaterial({color: COLORS.stone})); walls.position.y = 0.75; walls.castShadow = true; g.add(walls);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(2.2, 1.5, 4), new THREE.MeshLambertMaterial({color: COLORS.red})); roof.position.y = 1.5 + 0.75; roof.rotation.y = Math.PI/4; roof.scale.set(1, 1, 0.7); g.add(roof);
        return g;
    }
    function buildFireTemple() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 1.2, 8), new THREE.MeshLambertMaterial({color: 0x444444})); base.position.y = 0.6; g.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.8, 2, 8), new THREE.MeshLambertMaterial({color: COLORS.yellow})); roof.position.y = 1.2 + 1; g.add(roof);
        return g;
    }
    function buildSpyHut() {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 3, 1.2), new THREE.MeshLambertMaterial({color: 0x222222})); body.position.y = 1.5; g.add(body);
        const roof = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), new THREE.MeshLambertMaterial({color: COLORS.blue, emissive: 0x000044})); roof.position.y = 3.2; g.add(roof);
        return g;
    }
    function buildShipyard() {
        const g = new THREE.Group();
        // Dock platform
        const dock = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 4), new THREE.MeshLambertMaterial({color: COLORS.wood}));
        dock.position.y = 0.25; g.add(dock);
        // Small crane/post
        const post = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3), new THREE.MeshLambertMaterial({color: COLORS.stone}));
        post.position.set(1, 1.5, 1); g.add(post);
        const arm = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 0.2), new THREE.MeshLambertMaterial({color: COLORS.wood}));
        arm.position.set(0, 3, 1); g.add(arm);
        return g;
    }

    // --- TERRAIN FUNCTIONS ---
    function isBraveNearby(faction, x, z, radius) {
        for(let u of units) {
            if(u.faction === faction && u.type === 'wild' && u.state !== 'dead') {
                const dist = Math.sqrt((u.mesh.position.x - x)**2 + (u.mesh.position.z - z)**2);
                if(dist <= radius) return true;
            }
        }
        return false;
    }

    function findNearestLand(x, z, maxRadius = 20) {
        if(getHeight(x, z) >= 2.0) return {x, z};

        // Spiral search
        for(let r = 2; r <= maxRadius; r += 2) {
            const steps = Math.floor(2 * Math.PI * r / 2); // roughly 2 unit spacing
            for(let i = 0; i < steps; i++) {
                const angle = (i / steps) * Math.PI * 2;
                const nx = x + Math.cos(angle) * r;
                const nz = z + Math.sin(angle) * r;
                if(getHeight(nx, nz) >= 2.0) return {x: nx, z: nz};
            }
        }
        return {x, z}; // Fallback
    }

    function burnTreesAt(x, z, radius) {
        Object.values(chunks).forEach(chunk => {
            if(chunk.userData && chunk.userData.trees) {
                chunk.userData.trees.forEach(tree => {
                    if(tree.burned) return;
                    const dist = Math.sqrt((tree.mesh.position.x - x)**2 + (tree.mesh.position.z - z)**2);
                    if(dist < radius) {
                        tree.burned = true;
                        // Charred visual
                        const t = tree.mesh.children[0]; // Trunk
                        const l = tree.mesh.children[1]; // Leaves
                        t.material = t.material.clone();
                        t.material.color.setHex(0x111111); // Black trunk

                        l.material = l.material.clone();
                        l.material.color.setHex(0x222222); // Charred leaves
                        l.scale.set(0.8, 0.5, 0.8); // Shriveled

                        // Smoke
                        for(let i=0; i<3; i++) {
                            const p = new Particle(tree.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), 0x333333, 0.2, 2.0, -1);
                            particles.push(p);
                        }
                    }
                });
            }
        });
    }

    function modifyTerrain(centerX, centerZ, radius, amount) {
        const rSq = radius * radius;
        const modifiedChunks = new Set();
        for(let x = Math.floor(centerX - radius); x <= Math.ceil(centerX + radius); x++) {
            for(let z = Math.floor(centerZ - radius); z <= Math.ceil(centerZ + radius); z++) {
                const distSq = (x - centerX)**2 + (z - centerZ)**2;
                if (distSq <= rSq) {
                    const falloff = 1 - (distSq / rSq);
                    const key = `${x},${z}`;
                    const currentMod = terrainMods.get(key) || 0;
                    terrainMods.set(key, currentMod + (amount * falloff));
                    const cx = Math.round(x / CHUNK_SIZE);
                    const cz = Math.round(z / CHUNK_SIZE);
                    modifiedChunks.add(`${cx},${cz}`);
                }
            }
        }

        // Check if buildings collapse
        buildings.forEach(b => {
            const groundH = getHeight(b.mesh.position.x, b.mesh.position.z);
            if(Math.abs(groundH - b.mesh.position.y) > 1.0) {
                b.takeDamage(100); // Collapse damage
            }
        });
        return modifiedChunks;
    }

    function createVolcano(x, z) {
        activeEffects.push(new Volcano(x, z));
    }

    function updateChunks(force = false, specificChunks = null) {
        const cx = Math.round(cameraLookAt.x / CHUNK_SIZE);
        const cz = Math.round(cameraLookAt.z / CHUNK_SIZE);
        const activeKeys = new Set();
        let createdCount = 0;
        const MAX_CHUNKS_PER_FRAME = 2;

        for(let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
            for(let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                const key = (cx+x) + "," + (cz+z);
                activeKeys.add(key);
                if(!chunks[key] || (force && (!specificChunks || specificChunks.has(key)))) {

                    if (!chunks[key] && createdCount >= MAX_CHUNKS_PER_FRAME) continue;

                    if(chunks[key]) {
                        scene.remove(chunks[key]);
                        // Only dispose terrain geometry (child 0), water (child 1) is shared
                        if(chunks[key].children[0] && chunks[key].children[0].geometry) chunks[key].children[0].geometry.dispose();
                    }
                    chunks[key] = createChunk(cx+x, cz+z); 
                    scene.add(chunks[key]); 
                    createdCount++;
                }
            }
        }
        if(!force) {
            for(let key in chunks) {
                if(!activeKeys.has(key)) {
                    scene.remove(chunks[key]);
                    // Only dispose terrain geometry
                    if(chunks[key].children[0] && chunks[key].children[0].geometry) chunks[key].children[0].geometry.dispose();
                    delete chunks[key];
                }
            }
        }
    }

    let chunkTerrainMat, chunkWaterGeo, chunkWaterMat;

    function createChunk(cx, cz) {
        const grp = new THREE.Group();
        const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES, CHUNK_RES);
        geo.rotateX(-Math.PI/2);
        const pos = geo.attributes.position;
        const colors = []; const col = new THREE.Color();
        const offX = cx * CHUNK_SIZE; const offZ = cz * CHUNK_SIZE;

        const cWater = new THREE.Color(COLORS.water);
        const cSand = new THREE.Color(COLORS.sand);
        const cGrass = new THREE.Color(COLORS.grass);
        const cRock = new THREE.Color(COLORS.rock);
        const cSnow = new THREE.Color(COLORS.snow);
        const cLava = new THREE.Color(COLORS.lava);

        for(let i=0; i<pos.count; i++) {
            const wx = pos.getX(i) + offX; const wz = pos.getZ(i) + offZ;
            let h = getHeight(wx, wz);
            pos.setY(i, h);

            if (h < 2.0) col.copy(cSand);
            else if (h < 3.0) col.copy(cSand).lerp(cGrass, h - 2.0);
            else if (h < 8.0) col.copy(cGrass);
            else if (h < 9.0) col.copy(cGrass).lerp(cRock, h - 8.0);
            else if (h < 13.0) col.copy(cRock);
            else if (h < 15.0) col.copy(cRock).lerp(cSnow, (h - 13.0) / 2.0);
            else if (h < 19.0) col.copy(cSnow);
            else if (h < 21.0) col.copy(cSnow).lerp(cLava, (h - 19.0) / 2.0);
            else col.copy(cLava);

            if(h > 2.5) col.offsetHSL(0, 0, (Math.random()-0.5)*0.03);
            colors.push(col.r, col.g, col.b);
        }
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.computeVertexNormals();
        const mesh = new THREE.Mesh(geo, chunkTerrainMat);
        mesh.position.set(offX, 0, offZ); mesh.receiveShadow = true;
        grp.add(mesh);

        const wMesh = new THREE.Mesh(chunkWaterGeo, chunkWaterMat);
        wMesh.rotation.x = -Math.PI/2; wMesh.position.set(offX, 0.5, offZ);
        grp.add(wMesh);

        grp.userData = { trees: [] };
        for(let k=0; k<3; k++) {
            if(Math.random() > 0.5) {
                 const lx = (Math.random()-0.5)*CHUNK_SIZE; const lz = (Math.random()-0.5)*CHUNK_SIZE;
                 const h = getHeight(lx+offX, lz+offZ);
                 if(h > 3 && h < 8) {
                    const treeGroup = new THREE.Group();
                    treeGroup.position.set(lx+offX, h, lz+offZ);

                    const t = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.25,1,5), new THREE.MeshLambertMaterial({color:0x8B4513}));
                    t.position.y = 0.5; t.castShadow = true;

                    const l = new THREE.Mesh(new THREE.ConeGeometry(0.9,2.8,5), new THREE.MeshLambertMaterial({color:0x006400}));
                    l.position.y = 1.9; l.castShadow = true;

                    treeGroup.add(t); treeGroup.add(l);
                    grp.add(treeGroup);

                    grp.userData.trees.push({
                        mesh: treeGroup,
                        burned: false
                    });
                 }
            }
        }
        return grp;
    }

    // --- PATHFINDING ---
    class BinaryHeap {
        constructor(scoreFunction) { this.content = []; this.scoreFunction = scoreFunction; }
        push(element) { this.content.push(element); this.siftUp(this.content.length - 1); }
        pop() {
            const result = this.content[0]; const end = this.content.pop();
            if (this.content.length > 0) { this.content[0] = end; this.siftDown(0); }
            return result;
        }
        size() { return this.content.length; }
        siftUp(n) {
            const element = this.content[n];
            while (n > 0) {
                const parentN = Math.floor((n + 1) / 2) - 1;
                const parent = this.content[parentN];
                if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                    this.content[parentN] = element; this.content[n] = parent; n = parentN;
                } else break;
            }
        }
        siftDown(n) {
            const length = this.content.length; const element = this.content[n];
            while (true) {
                const child2N = (n + 1) * 2; const child1N = child2N - 1;
                let swap = null;
                if (child1N < length) {
                    const child1 = this.content[child1N];
                    if (this.scoreFunction(child1) < this.scoreFunction(element)) swap = child1N;
                }
                if (child2N < length) {
                    const child2 = this.content[child2N];
                    if (this.scoreFunction(child2) < (swap === null ? this.scoreFunction(element) : this.scoreFunction(this.content[child1N]))) swap = child2N;
                }
                if (swap !== null) { this.content[n] = this.content[swap]; this.content[swap] = element; n = swap; } else break;
            }
        }
    }

    const Pathfinder = {
        GRID_SIZE: 2.0,
        findPath: function(startPos, endPos, isFlying = false) {
            const startNode = { x: Math.round(startPos.x / this.GRID_SIZE), y: Math.round(startPos.z / this.GRID_SIZE) };
            const endNode = { x: Math.round(endPos.x / this.GRID_SIZE), y: Math.round(endPos.z / this.GRID_SIZE) };

            if(startNode.x === endNode.x && startNode.y === endNode.y) return [];

            const openHeap = new BinaryHeap(node => node.f);
            const openSet = new Map();
            const closedSet = new Set();

            startNode.g = 0; startNode.f = 0;
            openHeap.push(startNode);
            openSet.set(`${startNode.x},${startNode.y}`, startNode);

            let iterations = 0;
            const MAX_ITER = 2000;

            while(openHeap.size() > 0) {
                iterations++;
                if(iterations > MAX_ITER) break;

                const currentNode = openHeap.pop();
                const key = `${currentNode.x},${currentNode.y}`;
                openSet.delete(key);
                closedSet.add(key);

                if(currentNode.x === endNode.x && currentNode.y === endNode.y) {
                    const path = [];
                    let curr = currentNode;
                    while(curr.parent) {
                        path.push(new THREE.Vector3(curr.x * this.GRID_SIZE, 0, curr.y * this.GRID_SIZE));
                        curr = curr.parent;
                    }
                    return path.reverse();
                }

                const neighbors = [
                    {x:0,y:1}, {x:1,y:0}, {x:0,y:-1}, {x:-1,y:0},
                    {x:1,y:1}, {x:1,y:-1}, {x:-1,y:1}, {x:-1,y:-1}
                ];

                for(let offset of neighbors) {
                    const nx = currentNode.x + offset.x;
                    const ny = currentNode.y + offset.y;
                    const nKey = `${nx},${ny}`;

                    if(closedSet.has(nKey)) continue;

                    const wx = nx * this.GRID_SIZE;
                    const wz = ny * this.GRID_SIZE;
                    const h = getHeight(wx, wz);

                    if(!isFlying && h < 2.0) continue;

                    // Diagonal corner cutting check
                    if (Math.abs(offset.x) === 1 && Math.abs(offset.y) === 1) {
                        if (!isFlying) {
                            const h1 = getHeight((currentNode.x + offset.x) * this.GRID_SIZE, currentNode.y * this.GRID_SIZE);
                            const h2 = getHeight(currentNode.x * this.GRID_SIZE, (currentNode.y + offset.y) * this.GRID_SIZE);
                            if (h1 < 2.0 || h2 < 2.0) continue;
                        }
                    }

                    const dist = Math.sqrt(offset.x*offset.x + offset.y*offset.y);
                    const currentH = getHeight(currentNode.x * this.GRID_SIZE, currentNode.y * this.GRID_SIZE);
                    const dh = Math.abs(h - currentH);
                    if(!isFlying && dh > 2.0) continue;

                    const gScore = currentNode.g + dist + dh * 0.5;

                    let neighbor = openSet.get(nKey);
                    if(!neighbor) {
                        neighbor = { x: nx, y: ny, parent: currentNode, g: gScore, f: 0 };
                        const hScore = Math.sqrt((nx - endNode.x)**2 + (ny - endNode.y)**2);
                        neighbor.f = neighbor.g + hScore;
                        openHeap.push(neighbor);
                        openSet.set(nKey, neighbor);
                    } else if(gScore < neighbor.g) {
                        neighbor.g = gScore;
                        neighbor.parent = currentNode;
                        neighbor.f = neighbor.g + Math.sqrt((nx - endNode.x)**2 + (ny - endNode.y)**2);
                        openHeap.push(neighbor);
                    }
                }
            }
            return [endPos];
        }
    };
    window.Pathfinder = Pathfinder;

    // --- CHARACTER & PHYSICS ---
    class Humanoid {
        constructor(faction, type, x, z) {
            this.faction = faction; // 0 = Player, 1 = Enemy
            this.type = type; // 'wild', 'warrior', 'firewarrior', 'spy', 'shaman'
            this.isShaman = (type === 'shaman');

            // Stats
            this.maxHp = 100; this.damage = 5; this.range = 1; this.attackSpeed = 1.0; this.moveSpeed = 6;
            if(type === 'warrior') { this.maxHp = 200; this.damage = 15; }
            if(type === 'firewarrior') { this.maxHp = 120; this.damage = 25; this.range = 12; this.attackSpeed = 2.0; }
            if(type === 'shaman') { this.maxHp = 500; this.damage = 30; this.range = 15; }
            if(type === 'airship') { this.maxHp = 500; this.damage = 0; this.moveSpeed = 15; this.isVehicle = true; this.passengers = []; this.capacity = 5; }

            this.hp = this.maxHp; this.recoverTimer = 0;
            this.shielded = false;
            this.invisible = false;
            this.shieldMesh = null;

            // Visuals
            this.mesh = new THREE.Group();
            const color = faction === 0 ? COLORS.blue : COLORS.red;
            const skinMat = new THREE.MeshLambertMaterial({color: COLORS.skin});
            const shirtMat = new THREE.MeshLambertMaterial({color: color});
            
            // Selection Ring
            this.selectRing = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 16), new THREE.MeshBasicMaterial({color: 0x00FF00, side: THREE.DoubleSide}));
            this.selectRing.rotation.x = -Math.PI/2; this.selectRing.visible = false; this.mesh.add(this.selectRing);

            // HP Bar
            this.hpGroup = new THREE.Group(); this.hpGroup.position.set(0, 2.3, 0);
            this.hpGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.15), new THREE.MeshBasicMaterial({color: 0x880000})));
            const fgGeo = new THREE.PlaneGeometry(1.0, 0.15); fgGeo.translate(0.5, 0, 0); 
            this.hpBar = new THREE.Mesh(fgGeo, new THREE.MeshBasicMaterial({color: faction === 0 ? 0x00FF00 : 0xFF0000}));
            this.hpBar.position.x = -0.5; this.hpGroup.add(this.hpBar);
            this.mesh.add(this.hpGroup);

            // Body Parts
            if(type === 'airship') {
                 // Basket
                 const basket = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 3), new THREE.MeshLambertMaterial({color: COLORS.wood}));
                 basket.position.y = 0.5;
                 this.mesh.add(basket);
                 // Ropes
                 const rope1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshLambertMaterial({color: 0x888888}));
                 rope1.position.set(0.9, 2, 1.4); this.mesh.add(rope1);
                 const rope2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshLambertMaterial({color: 0x888888}));
                 rope2.position.set(-0.9, 2, 1.4); this.mesh.add(rope2);
                 const rope3 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshLambertMaterial({color: 0x888888}));
                 rope3.position.set(0.9, 2, -1.4); this.mesh.add(rope3);
                 const rope4 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3), new THREE.MeshLambertMaterial({color: 0x888888}));
                 rope4.position.set(-0.9, 2, -1.4); this.mesh.add(rope4);
                 // Balloon
                 const balloon = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16), new THREE.MeshLambertMaterial({color: 0xEEEEEE}));
                 balloon.scale.set(1, 0.8, 1.5);
                 balloon.position.set(0, 4.5, 0);
                 this.mesh.add(balloon);
            } else {
                this.torso = new THREE.Group(); this.torso.position.y = 0.9; this.mesh.add(this.torso);
                this.torso.add(new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.25), shirtMat));
                this.head = new THREE.Group(); this.head.position.y = 0.4; this.torso.add(this.head);
                this.head.add(new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.3), skinMat));
            }

            // Props
            if(this.isShaman) {
                const mask = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.1), new THREE.MeshLambertMaterial({color: 0xFFD700}));
                mask.position.z = 0.16; this.head.add(mask);
                const hornGeo = new THREE.ConeGeometry(0.04, 0.3, 4);
                const h1 = new THREE.Mesh(hornGeo, new THREE.MeshLambertMaterial({color:0xFFFFFF})); h1.position.set(0.15, 0.2, 0); h1.rotation.z = -0.3;
                const h2 = h1.clone(); h2.position.set(-0.15, 0.2, 0); h2.rotation.z = 0.3; this.head.add(h1); this.head.add(h2);
            } else if (type === 'warrior') {
                const helm = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8, 0, Math.PI * 2, 0, Math.PI/2), new THREE.MeshLambertMaterial({color: 0x555555}));
                helm.position.y = 0.1; this.head.add(helm);
            } else if (type === 'firewarrior') {
                const mask = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.1), new THREE.MeshLambertMaterial({color: 0xFF4500}));
                mask.position.z = 0.16; this.head.add(mask);
            }

            if (type !== 'airship') {
                const createLimb = (w, h, mat, px, py, pz) => {
                    const group = new THREE.Group(); group.position.set(px, py, pz);
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), mat); mesh.position.y = -h / 2; mesh.castShadow = true;
                    group.add(mesh); return group;
                };
                this.armL = createLimb(0.12, 0.45, skinMat, 0.26, 0.15, 0);
                this.armR = createLimb(0.12, 0.45, skinMat, -0.26, 0.15, 0);
                this.torso.add(this.armL); this.torso.add(this.armR);

                // Weapons
                if(type === 'warrior') {
                    const sword = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.1), new THREE.MeshLambertMaterial({color: 0xDDDDDD}));
                    sword.position.y = -0.3; sword.position.z = 0.1; sword.rotation.x = Math.PI/2;
                    this.armR.children[0].add(sword);
                }

                this.legL = createLimb(0.13, 0.55, shirtMat, 0.1, 0.65, 0);
                this.legR = createLimb(0.13, 0.55, shirtMat, -0.1, 0.65, 0);
                this.mesh.add(this.legL); this.mesh.add(this.legR);
            }

            this.mesh.position.set(x, getHeight(x,z), z);
            scene.add(this.mesh);
            this.velocity = new THREE.Vector3(0,0,0);
            this.isGrounded = true; this.target = null; this.attackTarget = null; this.state = 'idle'; this.animTime = Math.random() * 100;
            this.lastAttackTime = 0;
            this.path = []; this.pathIndex = 0; this.pathTimer = 0;
            this.finalDest = null; this.lastPos = new THREE.Vector3(); this.stuckTimer = 0;
            this.deathTimer = 0;
        }

        lookAtTarget(pos) {
            const dx = pos.x - this.mesh.position.x;
            const dz = pos.z - this.mesh.position.z;
            this.mesh.rotation.y = Math.atan2(dx, dz);
        }

        takeDamage(amount) {
            if(this.state === 'dead') return;
            if(this.shielded) {
                spawnPulse(this.mesh.position.x, this.mesh.position.y + 1, this.mesh.position.z, 0x00FFFF);
                return;
            }
            this.hp -= amount;
            this.hpBar.scale.x = Math.max(0, this.hp / this.maxHp);
            spawnPulse(this.mesh.position.x, this.mesh.position.y + 1, this.mesh.position.z, 0xFF0000);
            if(this.hp <= 0) this.die();
        }

        setShield(active) {
            this.shielded = active;
            if(active && !this.shieldMesh) {
                this.shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), new THREE.MeshBasicMaterial({color: 0x00FFFF, transparent: true, opacity: 0.3}));
                this.shieldMesh.position.y = 1.0;
                this.mesh.add(this.shieldMesh);
            } else if(!active && this.shieldMesh) {
                this.mesh.remove(this.shieldMesh);
                this.shieldMesh = null;
            }
        }

        setInvisibility(active) {
            this.invisible = active;
            this.mesh.traverse(c => {
                if(c.isMesh) {
                    c.material.transparent = true;
                    c.material.opacity = active ? 0.2 : 1.0;
                }
            });
        }

        die() {
            this.state = 'dead'; this.hpGroup.visible = false; this.velocity.set(0, 0, 0);
        }
        
        applyForce(vec) {
            if(this.state === 'dead') return;
            this.velocity.add(vec); this.isGrounded = false; this.state = 'stunned'; this.recoverTimer = 2.0; this.target = null;
        }

        goto(x, z) {
            if(this.state === 'stunned' || this.state === 'dead') return;
            const end = new THREE.Vector3(x, 0, z);
            this.finalDest = end.clone();
            const isFlying = (this.type === 'airship');
            this.path = Pathfinder.findPath(this.mesh.position, end, isFlying);
            this.pathIndex = 0;
            if(this.path.length > 0) {
                this.target = this.path[0];
                this.state = 'move';
            } else {
                this.target = end; this.state = 'move';
            }
        }
        
        findTarget() {
             // Find closest enemy
             let minDist = 1000;
             let closest = null;
             units.forEach(u => {
                 if(u.faction !== this.faction && u.state !== 'dead' && !u.invisible) {
                     const d = this.mesh.position.distanceTo(u.mesh.position);
                     if(d < 30 && d < minDist) {
                         minDist = d; closest = u;
                     }
                 }
             });
             // Also check for buildings?
             return closest;
        }

        attack() {
            if(!this.attackTarget || this.attackTarget.state === 'dead') {
                 this.state = 'idle'; this.attackTarget = null; return;
            }

            this.mesh.lookAt(this.attackTarget.mesh.position.x, this.mesh.position.y, this.attackTarget.mesh.position.z);

            // Animation
            const t = this.animTime * 10;
            this.armR.rotation.x = -Math.PI/2 + Math.sin(t) * 0.5; // Swing

            // Deal damage at right time
            // Simplified: just check cooldown
            if(clock.getElapsedTime() - this.lastAttackTime > (1.0/this.attackSpeed)) {
                this.lastAttackTime = clock.getElapsedTime();
                if(this.type === 'firewarrior') {
                    // Spawn Fireball
                     const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                     const targetPos = this.attackTarget.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
                     projectiles.push(new Fireball(startPos, targetPos, this.faction));
                     SoundManager.playSound('fireball');
                } else {
                    // Melee
                    this.attackTarget.takeDamage(this.damage);
                    SoundManager.playSound('attack');
                }
            }
        }

        update(dt) {
            if(this.state === 'transported') return;
            this.hpGroup.lookAt(camera.position); this.animTime += dt;
            if(!this.isGrounded) this.velocity.y -= 30 * dt; 
            else { this.velocity.x *= 0.9; this.velocity.z *= 0.9; }
            this.mesh.position.addScaledVector(this.velocity, dt);

            const groundH = getHeight(this.mesh.position.x, this.mesh.position.z);
            if (this.type === 'airship') {
                const targetAlt = Math.max(groundH, 2.0) + 8.0; // Fly above water or ground
                const diff = targetAlt - this.mesh.position.y;
                this.velocity.y += diff * dt * 5.0;
                this.velocity.y *= 0.9;
                this.isGrounded = false;
            } else {
                if (this.mesh.position.y < groundH) {
                    if(this.velocity.y < -15 && this.state !== 'dead' && !this.isShaman) this.takeDamage(10);
                    this.mesh.position.y = groundH + 0.35;
                    this.isGrounded = true; this.velocity.y = 0;
                    if(this.state === 'stunned' && this.velocity.length() < 1) { this.state = 'idle'; this.mesh.rotation.z = 0; this.mesh.rotation.x = 0; }
                } else if (this.mesh.position.y > groundH + 0.35) { this.isGrounded = false; }
            }

            // Water constraint
            const WATER_LEVEL = 2.0;
            if (this.type !== 'airship' && this.state !== 'dead') {
                const h = getHeight(this.mesh.position.x, this.mesh.position.z);
                if (h < WATER_LEVEL) {
                    // Units lose 10% HP per second in water
                    this.takeDamage(this.maxHp * 0.10 * dt);

                    // Automatically swim to land if not already moving
                    // We set state to 'move' and target to nearest land
                    // If target is null or not a land spot, find one.
                    const isMovingToLand = (this.state === 'move' && this.target && getHeight(this.target.x, this.target.z) >= 2.0);

                    if (!isMovingToLand) {
                        const safe = findNearestLand(this.mesh.position.x, this.mesh.position.z, 30);
                        if (safe.x !== this.mesh.position.x || safe.z !== this.mesh.position.z) {
                            this.goto(safe.x, safe.z);
                        }
                    }
                }
            }

            // Building Entry Check for Training
            if(this.type === 'wild' && this.state !== 'dead' && this.faction === 0) {
                 buildings.forEach(b => {
                     // Check if building is ready to train?
                     // For now instant training logic
                     const dist = this.mesh.position.distanceTo(b.mesh.position);
                     if(dist < 2.0 && b.hp > 0 && !b.training) {
                         let newType = null;
                         if(b.type === 'warrior') newType = 'warrior';
                         if(b.type === 'fire') newType = 'firewarrior';
                         if(b.type === 'spy') newType = 'spy'; // not implemented fully visual wise but logic is here

                         if(newType) {
                             // Enter building
                             this.die(); // Remove old unit
                             scene.remove(this.mesh); // Hide immediately
                             this.hp = 0; // Ensure cleaned up

                             // Start training timer on building
                             b.training = true;
                             b.trainTimer = 2.0;
                             b.trainType = newType;
                             b.trainFaction = this.faction;
                             spawnPulse(b.mesh.position.x, b.mesh.position.y+2, b.mesh.position.z, 0x00FF00);
                         }
                     }
                 });
            }

            if (this.state === 'dead') {
                this.deathTimer += dt;
                if(this.mesh.rotation.x > -Math.PI/2) this.mesh.rotation.x -= dt * 5;

                if (this.deathTimer > 95) {
                    if(this.mesh.position.y > groundH - 2.0) this.mesh.position.y -= dt * 0.5;
                }
                return; 
            }

            // Passive Healing near Buildings
            if(this.hp < this.maxHp && this.state !== 'combat') {
                let nearBuilding = false;
                for(let b of buildings) {
                    if(b.faction === this.faction && !b.dead) {
                        const dist = this.mesh.position.distanceTo(b.mesh.position);
                        if(dist < 8.0) {
                            nearBuilding = true;
                            break;
                        }
                    }
                }
                if(nearBuilding) {
                    this.hp += dt * 10;
                    if(this.hp > this.maxHp) this.hp = this.maxHp;
                    this.hpBar.scale.x = Math.max(0, this.hp / this.maxHp);

                    this.healTimer = (this.healTimer || 0) + dt;
                    if(this.healTimer > 0.5) {
                        spawnHealing(this.mesh.position.x, this.mesh.position.y + 2, this.mesh.position.z);
                        this.healTimer = 0;
                    }
                }
            }

            if(this.state === 'stunned') {
                if(this.velocity.length() > 2 || !this.isGrounded) {
                     this.mesh.rotation.x += dt * 5; this.mesh.rotation.z += dt * 3;
                     if(this.legL) {
                        this.legL.rotation.x = Math.sin(this.animTime * 15); this.legR.rotation.x = Math.sin(this.animTime * 15 + Math.PI);
                        this.armL.rotation.x = Math.sin(this.animTime * 15); this.armR.rotation.x = Math.sin(this.animTime * 15 + Math.PI);
                     }
                } else {
                    this.recoverTimer -= dt;
                    const targetRotX = -Math.PI/2;
                    this.mesh.rotation.x += (targetRotX - this.mesh.rotation.x) * 5 * dt;
                    this.mesh.rotation.z *= 0.9; 
                    this.resetAnim();
                    if(this.recoverTimer <= 0) { this.state = 'idle'; this.mesh.rotation.x = 0; }
                }
            }
            else if(this.state === 'combat') {
                if(!this.attackTarget || this.attackTarget.state === 'dead') {
                    // Try find new target
                    this.attackTarget = this.findTarget();
                    if(!this.attackTarget) { this.state = 'idle'; return; }
                }

                const dist = this.mesh.position.distanceTo(this.attackTarget.mesh.position);
                if(dist <= this.range) {
                    // In range, attack
                    this.velocity.set(0,0,0);
                    this.attack();
                } else {
                    // Pathfinding for combat
                    this.pathTimer += dt;
                    let targetPos = this.attackTarget.mesh.position;

                    if(this.pathTimer > 1.0) {
                         this.pathTimer = 0;
                         const isFlying = (this.type === 'airship');
                         // Only recalculate if far
                         if(dist > 10) {
                             this.path = Pathfinder.findPath(this.mesh.position, targetPos, isFlying);
                             this.pathIndex = 0;
                         } else {
                             this.path = []; // Close enough for direct
                         }
                    }

                    if(this.path && this.path.length > 0 && this.pathIndex < this.path.length) {
                        targetPos = this.path[this.pathIndex];
                        if(this.mesh.position.distanceTo(targetPos) < 1.0) {
                            this.pathIndex++;
                            if(this.pathIndex < this.path.length) targetPos = this.path[this.pathIndex];
                        }
                    }

                    // Move towards
                    const dx = targetPos.x - this.mesh.position.x;
                    const dz = targetPos.z - this.mesh.position.z;
                    const dir = new THREE.Vector3(dx, 0, dz).normalize();

                    // Slope check
                    const nextH = getHeight(this.mesh.position.x + dir.x, this.mesh.position.z + dir.z);
                    const dh = nextH - getHeight(this.mesh.position.x, this.mesh.position.z);

                    let canMove = true;
                    // Prevent entering water from land
                    // But allow moving if already in water (swimming)
                    if(this.type !== 'airship') {
                        const currentH = getHeight(this.mesh.position.x, this.mesh.position.z);
                        if(nextH < 2.0 && currentH >= 2.0) canMove = false;
                    }

                    if(canMove) {
                        const slopeFactor = dh > 0 ? (1.0 / (1.0 + dh * 3.0)) : 1.0;
                        const speed = this.moveSpeed * (this.type === 'airship' ? 1.0 : slopeFactor);
                        this.velocity.x = dir.x * speed; this.velocity.z = dir.z * speed;
                        this.mesh.rotation.y = Math.atan2(dx, dz);
                    } else {
                        this.velocity.set(0,0,0);
                    }

                    // Walk Anim
                    if(this.legL) {
                        const walkSpeed = 10; const amp = 0.8;
                        this.legL.rotation.x = Math.sin(this.animTime * walkSpeed) * amp;
                        this.legR.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp;
                        this.armL.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp * 0.6;
                        this.armR.rotation.x = Math.sin(this.animTime * walkSpeed) * amp * 0.6;
                    }
                }
            }
            else if(this.state === 'move' && this.target && (this.isGrounded || this.type === 'airship')) {
                // Stuck Detection
                const movedDist = this.mesh.position.distanceTo(this.lastPos);
                if(dt > 0.001) {
                    if(movedDist < this.moveSpeed * dt * 0.2) {
                        this.stuckTimer += dt;
                        if(this.stuckTimer > 2.0 && this.finalDest) {
                            this.stuckTimer = 0;
                            const isFlying = (this.type === 'airship');
                            this.path = Pathfinder.findPath(this.mesh.position, this.finalDest, isFlying);
                            this.pathIndex = 0;
                            if(this.path.length > 0) this.target = this.path[0];
                        }
                    } else {
                        this.stuckTimer = 0;
                    }
                }
                this.lastPos.copy(this.mesh.position);

                let dx = this.target.x - this.mesh.position.x;
                let dz = this.target.z - this.mesh.position.z;
                let dist = Math.sqrt(dx*dx + dz*dz);

                // Update Path
                if(dist < 1.0) {
                     this.pathIndex++;
                     if(this.path && this.pathIndex < this.path.length) {
                         this.target = this.path[this.pathIndex];
                         dx = this.target.x - this.mesh.position.x;
                         dz = this.target.z - this.mesh.position.z;
                         dist = Math.sqrt(dx*dx + dz*dz);
                     } else {
                        this.state = 'idle'; this.velocity.set(0,0,0); this.resetAnim();
                        this.targetBoat = null;
                        this.path = [];
                        return;
                     }
                }

                // Check boat entry while moving (allow early entry)
                if(this.targetBoat && this.targetBoat.state !== 'dead') {
                     // 3D distance check, ignore Y difference essentially for trigger
                     const distSq = (this.mesh.position.x - this.targetBoat.mesh.position.x)**2 + (this.mesh.position.z - this.targetBoat.mesh.position.z)**2;
                     if(distSq < 25.0) { // 5.0 distance squared
                         if(this.targetBoat.loadUnit(this)) {
                             this.targetBoat = null;
                             this.state = 'idle'; this.velocity.set(0,0,0);
                             return;
                         }
                     }
                }

                if(true) {
                    const dir = new THREE.Vector3(dx, 0, dz).normalize();

                    // Slope check
                    const nextH = getHeight(this.mesh.position.x + dir.x, this.mesh.position.z + dir.z);
                    const dh = nextH - getHeight(this.mesh.position.x, this.mesh.position.z);

                    let canMove = true;
                    // Prevent entering water from land unless targeting boat
                    // Allow moving if already in water (swimming)
                    if(this.type !== 'airship') {
                        const currentH = getHeight(this.mesh.position.x, this.mesh.position.z);
                        if (nextH < 2.0 && currentH >= 2.0) {
                             if(!this.targetBoat) canMove = false;
                        }
                    }

                    if(canMove) {
                        const slopeFactor = dh > 0 ? (1.0 / (1.0 + dh * 3.0)) : 1.0;
                        const speed = this.moveSpeed * (this.type === 'airship' ? 1.0 : slopeFactor);
                        this.velocity.x = dir.x * speed; this.velocity.z = dir.z * speed;
                        this.mesh.rotation.y = Math.atan2(dx, dz);
                    } else {
                         this.velocity.set(0,0,0);
                         this.state = 'idle'; // Stop moving if hit water
                         this.resetAnim();
                    }
                    this.mesh.rotation.x = 0; this.mesh.rotation.z = 0;
                    if(this.legL) {
                        const walkSpeed = 10; const amp = 0.8;
                        this.legL.rotation.x = Math.sin(this.animTime * walkSpeed) * amp;
                        this.legR.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp;
                        this.armL.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp * 0.6;
                        this.armR.rotation.x = Math.sin(this.animTime * walkSpeed) * amp * 0.6;
                        this.torso.position.y = 0.9 + Math.abs(Math.sin(this.animTime * walkSpeed)) * 0.05;
                    }
                }
            } else {
                // Idle Check Aggro
                // All unselected units auto aggro
                if (!selectedUnits.includes(this)) {
                    const target = this.findTarget();
                    if(target) {
                        this.attackTarget = target;
                        this.state = 'combat';
                    }
                }

                this.resetAnim();
                if(this.torso) {
                    this.torso.position.y = 0.9 + Math.sin(this.animTime * 2) * 0.02;
                    this.armL.rotation.z = Math.sin(this.animTime) * 0.05 + 0.1;
                    this.armR.rotation.z = -Math.sin(this.animTime) * 0.05 - 0.1;
                }
                this.mesh.rotation.x *= 0.8; this.mesh.rotation.z *= 0.8;
            }
        }
        resetAnim() {
            const lerp = 0.1;
            if(this.legL) this.legL.rotation.x += (0 - this.legL.rotation.x) * lerp;
            if(this.legR) this.legR.rotation.x += (0 - this.legR.rotation.x) * lerp;
            if(this.armL) this.armL.rotation.x += (0 - this.armL.rotation.x) * lerp;
            if(this.armR) this.armR.rotation.x += (0 - this.armR.rotation.x) * lerp;
        }

        loadUnit(u) {
            if(this.passengers.length >= this.capacity) return false;
            this.passengers.push(u);
            u.mesh.visible = false;
            u.state = 'transported';
            u.transportedBy = this;
            return true;
        }

        unload() {
            if(!this.passengers.length) return;

            // Unload below airship if safe, or find safe spot
            const r = 5; // Scan larger area
            for(let i=this.passengers.length-1; i>=0; i--) {
                const p = this.passengers[i];
                // Check directly below first
                let tx = this.mesh.position.x;
                let tz = this.mesh.position.z;
                if (getHeight(tx, tz) < 2.0) {
                    // Try find land in radius
                    let found = false;
                    for(let dist=1; dist<=r; dist+=1) {
                        for(let angle=0; angle<Math.PI*2; angle+=0.5) {
                            const scanX = this.mesh.position.x + Math.cos(angle)*dist;
                            const scanZ = this.mesh.position.z + Math.sin(angle)*dist;
                            if(getHeight(scanX, scanZ) >= 2.0) {
                                tx = scanX; tz = scanZ; found = true; break;
                            }
                        }
                        if(found) break;
                    }
                    if(!found) continue; // Can't unload this unit safely yet
                }

                p.mesh.position.set(tx, getHeight(tx, tz), tz);
                p.mesh.visible = true;
                p.state = 'idle';
                p.transportedBy = null;
                this.passengers.splice(i, 1);
                spawnPulse(tx, p.mesh.position.y, tz, 0xFFFFFF);
            }
        }
    }

    // --- ENEMY AI ---
    class EnemyAI {
        constructor() {
            this.timer = 0;
            this.state = 'build'; // 'build', 'attack'
            this.baseX = 0;
            this.baseZ = 0;
            this.lastBridgeTime = 0;
        }

        init(x, z) {
            // Ensure base is on land
            const startSafe = findNearestLand(x, z, 50);
            this.baseX = startSafe.x;
            this.baseZ = startSafe.z;

            // Create initial base
            createBuilding('hut', this.baseX, this.baseZ, 1);
            // Create some units
            for(let i=0; i<3; i++) {
                const spawnX = this.baseX + (Math.random()-0.5)*5;
                const spawnZ = this.baseZ + (Math.random()-0.5)*5;
                const safe = findNearestLand(spawnX, spawnZ);
                units.push(new Humanoid(1, 'wild', safe.x, safe.z));
            }
            // Create Enemy Shaman
            const shamanSafe = findNearestLand(this.baseX - 5, this.baseZ - 5, 20);
            units.push(new Humanoid(1, 'shaman', shamanSafe.x, shamanSafe.z));

            // Create a tower
            const towerSafe = findNearestLand(this.baseX + 5, this.baseZ + 5, 20);
            createBuilding('tower', towerSafe.x, towerSafe.z, 1);
        }

        update(dt) {
            this.timer += dt;
            if(this.timer > 5.0) {
                this.timer = 0;
                this.think();
            }
        }

        think() {
            // Get Enemy Units
            const myUnits = units.filter(u => u.faction === 1 && u.state !== 'dead');
            const myBuildings = buildings.filter(b => b.faction === 1 && !b.dead);

            // 1. Train Units
            // If I have Braves and Buildings, train.
            // Simplified: Just spawn occasionally for challenge.
            if(Math.random() < 0.3) {
                 const type = Math.random() > 0.5 ? 'warrior' : 'firewarrior';
                 const spawnX = this.baseX + (Math.random()-0.5)*10;
                 const spawnZ = this.baseZ + (Math.random()-0.5)*10;
                 const safe = findNearestLand(spawnX, spawnZ);
                 units.push(new Humanoid(1, type, safe.x, safe.z));
            }

            // 2. Expand Base
            const myBraves = myUnits.filter(u => u.type === 'wild');
            // Aggressive expansion: always try if we have at least one building and one brave (busy or idle)
            if (myBuildings.length > 0 && myBraves.length > 0) {
                // Try up to 10 times to find a spot per think cycle
                for(let attempt=0; attempt<10; attempt++) {
                    // Pick a brave as reference to satisfy "build only near brave"
                    const ref = myBraves[Math.floor(Math.random() * myBraves.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 2 + Math.random() * 6; // Closer range (2-8) to ensure brave is "nearby" (within 10)
                    let tx = ref.mesh.position.x + Math.cos(angle) * dist;
                    let tz = ref.mesh.position.z + Math.sin(angle) * dist;

                    // Snap to land (function is hoisted and available)
                    const safe = findNearestLand(tx, tz, 20);
                    tx = safe.x; tz = safe.z;

                    // Check land validity again (just in case)
                    if (getHeight(tx, tz) >= 2.0) {
                        // Check spacing
                        let clear = true;
                        for (let b of buildings) {
                            if (!b.dead && b.mesh.position.distanceTo(new THREE.Vector3(tx, b.mesh.position.y, tz)) < 6.0) {
                                clear = false; break;
                            }
                        }
                        if (clear) {
                            const types = ['hut', 'tower', 'warrior', 'fire', 'spy', 'shipyard'];
                            const type = types[Math.floor(Math.random() * types.length)];
                            createBuilding(type, tx, tz, 1);
                            break; // Built one, stop trying this frame
                        }
                    }
                }
            }

            // 4. Random Movement for Expansion (Braves)
            const idleBraves = myUnits.filter(u => u.type === 'wild');
            idleBraves.forEach(u => {
                if(u.state === 'idle' && Math.random() < 0.5) { // 50% chance to move if idle
                     const dist = 10 + Math.random() * 20;
                     const angle = Math.random() * Math.PI * 2;
                     const tx = u.mesh.position.x + Math.cos(angle) * dist;
                     const tz = u.mesh.position.z + Math.sin(angle) * dist;
                     const safe = findNearestLand(tx, tz, 20);
                     u.goto(safe.x, safe.z);
                }
            });

            // 3. Attack Player
            if(myUnits.length > 5) {
                // Send some to attack player shaman
                const attackers = myUnits.filter(u => u.type !== 'wild' && u.state === 'idle');
                const target = shaman;
                if(target && target.state !== 'dead') {
                    attackers.forEach(u => {
                        u.goto(target.mesh.position.x, target.mesh.position.z);
                        u.attackTarget = target;
                        u.state = 'combat'; // Force combat state approach
                    });
                }
            }

            // 4. Shaman Logic (Landbridge)
            const myShaman = myUnits.find(u => u.isShaman);
            const target = shaman; // Player shaman
            if(myShaman && target && target.state !== 'dead') {
                const dist = myShaman.mesh.position.distanceTo(target.mesh.position);
                // Check cooldown
                if (clock.getElapsedTime() - this.lastBridgeTime > 10.0) {
                    // Check for water in path
                    const steps = 10;
                    let waterFound = false;
                    const dir = target.mesh.position.clone().sub(myShaman.mesh.position).normalize();

                    for(let i=1; i<=steps; i++) {
                        const checkPos = myShaman.mesh.position.clone().addScaledVector(dir, i * 4.0); // Check ahead 40 units
                        if (getHeight(checkPos.x, checkPos.z) < 2.0) {
                            waterFound = true;
                            break;
                        }
                    }

                    if (waterFound) {
                        // Cast Bridge towards player (limited distance)
                        const bridgeTarget = myShaman.mesh.position.clone().addScaledVector(dir, 30.0);
                        castLandbridge(myShaman, bridgeTarget.x, bridgeTarget.z);
                        this.lastBridgeTime = clock.getElapsedTime();
                    }
                }

                // Also move shaman to attack if idle
                if (myShaman.state === 'idle' && dist > 20) {
                     myShaman.goto(target.mesh.position.x, target.mesh.position.z);
                }
            }
        }
    }
    const enemyAI = new EnemyAI(); window.enemyAI = enemyAI;

    // --- HELPER CLASSES (Particles, Fireball, Effects) ---
    class ActiveEffect {
        constructor() {}
        update(dt) { return false; }
    }

    class Volcano extends ActiveEffect {
        constructor(x, z) {
            super();
            this.x = x; this.z = z;
            this.timer = 15.0;
            this.interval = 0;
            SoundManager.playSound('explosion');
            // Initial rise
            const mods = modifyTerrain(x, z, 8, 5);
            updateChunks(true, mods);
        }
        update(dt) {
            this.timer -= dt;
            this.interval += dt;

            // Visuals
            if(Math.random() < 0.5) {
                const dist = Math.random() * 4;
                const angle = Math.random() * Math.PI * 2;
                const px = this.x + Math.cos(angle) * dist;
                const pz = this.z + Math.sin(angle) * dist;
                const h = getHeight(px, pz);
                const p = new Particle(new THREE.Vector3(px, h, pz), COLORS.lava, 0.3 + Math.random()*0.3, 1.5);
                p.vel.set((Math.random()-0.5)*4, Math.random()*8+4, (Math.random()-0.5)*4);
                particles.push(p);
            }

            if(this.interval > 0.2) {
                this.interval = 0;
                // Continually raise/modify
                const mods = modifyTerrain(this.x, this.z, 5, 0.2);
                updateChunks(true, mods);

                burnTreesAt(this.x, this.z, 10);

                // Push & Damage
                units.forEach(u => {
                    const dist = u.mesh.position.distanceTo(new THREE.Vector3(this.x, u.mesh.position.y, this.z));
                    if(dist < 10) {
                        const dir = u.mesh.position.clone().sub(new THREE.Vector3(this.x, u.mesh.position.y, this.z)).normalize();
                        u.applyForce(dir.multiplyScalar(20).add(new THREE.Vector3(0, 10, 0)));
                        if (!u.isShaman) u.takeDamage(5);
                    }
                });
                buildings.forEach(b => {
                     const dist = b.mesh.position.distanceTo(new THREE.Vector3(this.x, b.mesh.position.y, this.z));
                     if(dist < 10) b.takeDamage(10);
                });
            }
            return this.timer > 0;
        }
    }

    class Swamp extends ActiveEffect {
        constructor(x, z) {
            super();
            this.pos = new THREE.Vector3(x, getHeight(x,z)+0.1, z);
            this.timer = 30.0;
            this.radius = 4.0;

            const geo = new THREE.CylinderGeometry(this.radius, this.radius, 0.2, 16);
            const mat = new THREE.MeshBasicMaterial({color: 0x2F4F4F, transparent: true, opacity: 0.8});
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.copy(this.pos);
            scene.add(this.mesh);
            SoundManager.playSound('magic');
        }
        update(dt) {
            this.timer -= dt;

            // Visual pulse
            this.mesh.scale.setScalar(1.0 + Math.sin(this.timer * 2) * 0.05);

            // Kill units
            for(let i = units.length-1; i>=0; i--) {
                const u = units[i];
                if(u.state !== 'dead' && !u.isShaman) {
                    const dist = Math.sqrt((u.mesh.position.x - this.pos.x)**2 + (u.mesh.position.z - this.pos.z)**2);
                    if(dist < this.radius * 0.8) {
                         u.takeDamage(10000); // Instant death
                         spawnPulse(u.mesh.position.x, u.mesh.position.y, u.mesh.position.z, 0x000000);
                    }
                }
            }

            if(this.timer <= 0) {
                scene.remove(this.mesh);
                return false;
            }
            return true;
        }
    }

    class Tornado extends ActiveEffect {
        constructor(x, z) {
            super();
            this.pos = new THREE.Vector3(x, getHeight(x,z), z);
            this.timer = 20.0;
            this.angle = Math.random() * Math.PI * 2;
            this.mesh = new THREE.Group();

            // Visuals
            for(let i=0; i<20; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color: 0xAAAAAA}));
                p.userData = { yOff: i * 0.5, r: 1 + i*0.2, ang: i };
                this.mesh.add(p);
            }
            scene.add(this.mesh);
            SoundManager.playSound('rumble');
        }
        update(dt) {
            this.timer -= dt;

            // Move Randomly
            this.angle += (Math.random()-0.5) * 2 * dt;
            const speed = 8;
            this.pos.x += Math.cos(this.angle) * speed * dt;
            this.pos.z += Math.sin(this.angle) * speed * dt;
            this.pos.y = getHeight(this.pos.x, this.pos.z);

            this.mesh.position.copy(this.pos);

            // Animate Visuals
            this.mesh.children.forEach(c => {
                 c.userData.ang += dt * 10;
                 c.position.set(Math.cos(c.userData.ang)*c.userData.r, c.userData.yOff, Math.sin(c.userData.ang)*c.userData.r);
            });

            // Physics
            units.forEach(u => {
                const d = u.mesh.position.distanceTo(this.pos);
                if(d < 5 && !u.isShaman) {
                     u.applyForce(new THREE.Vector3((Math.random()-0.5)*10, 25, (Math.random()-0.5)*10));
                     u.takeDamage(2);
                }
            });
            buildings.forEach(b => {
                 const d = b.mesh.position.distanceTo(this.pos);
                 if(d < 5) b.takeDamage(5);
            });

            if(this.timer <= 0) {
                scene.remove(this.mesh);
                return false;
            }
            return true;
        }
    }

    class Swarm extends ActiveEffect {
        constructor(x, z) {
            super();
            this.pos = new THREE.Vector3(x, getHeight(x,z)+3, z);
            this.timer = 20.0;
            this.particles = [];
            for(let i=0; i<30; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({color: 0x000000}));
                p.position.set((Math.random()-0.5)*4, (Math.random()-0.5)*2, (Math.random()-0.5)*4);
                // this.pos.add(p.position); // Removed erroneous accumulation
                this.particles.push({mesh: p, off: p.position.clone()});
                scene.add(p);
            }
        }
        update(dt) {
            this.timer -= dt;

            // Move towards nearest enemy
            let closest = null; let minDist = 50;
            units.forEach(u => {
                 if(u.faction === 1 && u.state !== 'dead') {
                     const d = u.mesh.position.distanceTo(this.pos);
                     if(d < minDist) { minDist = d; closest = u; }
                 }
            });

            if(closest) {
                 const dir = closest.mesh.position.clone().add(new THREE.Vector3(0,2,0)).sub(this.pos).normalize();
                 this.pos.addScaledVector(dir, 10 * dt);
            }

            // Update particles
            this.particles.forEach(p => {
                p.off.applyAxisAngle(new THREE.Vector3(0,1,0), dt * 2);
                p.mesh.position.copy(this.pos).add(p.off);
            });

            // Damage
            units.forEach(u => {
                const d = u.mesh.position.distanceTo(this.pos);
                if(d < 4) {
                    u.takeDamage(50 * dt);
                }
            });

            if(this.timer <= 0) {
                this.particles.forEach(p => scene.remove(p.mesh));
                return false;
            }
            return true;
        }
    }

    class Firestorm extends ActiveEffect {
        constructor(x, z, faction) {
            super();
            this.x = x; this.z = z;
            this.faction = faction;
            this.timer = 10.0;
            this.interval = 0;
        }
        update(dt) {
            this.timer -= dt;
            this.interval += dt;
            if(this.interval > 0.5) {
                this.interval = 0;
                const rx = this.x + (Math.random()-0.5)*15;
                const rz = this.z + (Math.random()-0.5)*15;
                const start = new THREE.Vector3(rx, 40, rz);
                const end = new THREE.Vector3(rx, getHeight(rx, rz), rz);
                projectiles.push(new Fireball(start, end, this.faction));
                SoundManager.playSound('fireball');
            }
            return this.timer > 0;
        }
    }

    class Particle {
        constructor(pos, color, size, life, gravity = 20) {
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({color: color}));
            this.mesh.position.copy(pos);
            this.vel = new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10+5, (Math.random()-0.5)*10);
            this.life = life; this.gravity = gravity; scene.add(this.mesh);
        }
        update(dt) {
            this.vel.y -= this.gravity * dt; this.mesh.position.addScaledVector(this.vel, dt);
            this.mesh.rotation.x += dt*2; this.mesh.rotation.y += dt*2; this.life -= dt;
            const h = getHeight(this.mesh.position.x, this.mesh.position.z);
            if(this.mesh.position.y < h) { this.mesh.position.y = h; this.vel.y *= -0.5; this.vel.x *= 0.8; this.vel.z *= 0.8; }
            if(this.life <= 0) { scene.remove(this.mesh); return false; } return true;
        }
    }

    class Fireball {
        constructor(start, end, faction) {
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({color: 0xFF4500}));
            this.mesh.position.copy(start); this.target = end; this.dir = end.clone().sub(start).normalize();
            this.faction = faction;
            this.speed = 25; this.active = true; this.trailTimer = 0; scene.add(this.mesh);
        }
        update(dt) {
            if(!this.active) return false;
            this.mesh.position.addScaledVector(this.dir, this.speed * dt); this.trailTimer += dt;
            if(this.trailTimer > 0.05) { particles.push(new Particle(this.mesh.position, 0xFFA500, 0.05, 0.5)); this.trailTimer = 0; }
            const dist = this.mesh.position.distanceTo(this.target);
            if(dist < 1.0 || getHeight(this.mesh.position.x, this.mesh.position.z) > this.mesh.position.y) { this.explode(); return false; } return true;
        }
        explode() {
            scene.remove(this.mesh); this.active = false;
            spawnExplosion(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, 0xFF4500, 20);
            SoundManager.playSound('explosion');
            const impactPos = this.mesh.position;
            burnTreesAt(impactPos.x, impactPos.z, 8); // Burn trees
            // Units
            units.forEach(u => {
                const d = u.mesh.position.distanceTo(impactPos);
                if(d < 8) {
                    if (!u.isShaman || u.faction !== this.faction) {
                        const forceDir = u.mesh.position.clone().sub(impactPos).normalize(); const force = (8 - d) * 3;
                        forceDir.multiplyScalar(force); forceDir.y += force * 0.5;
                        u.applyForce(forceDir); u.takeDamage(27);
                    }
                }
            });
            // Buildings
            buildings.forEach(b => {
                const d = b.mesh.position.distanceTo(impactPos);
                if(d < 8) {
                    b.takeDamage(75); // Fireball deals 75 damage to buildings
                }
            });
        }
    }

    function spawnExplosion(x, y, z, color, count) { for(let i=0; i<count; i++) particles.push(new Particle(new THREE.Vector3(x, y, z), color, 0.1+Math.random()*0.1, 1.0+Math.random())); }
    function spawnPulse(x, y, z, color) { particles.push(new Particle(new THREE.Vector3(x, y+0.5, z), color, 0.05, 0.5)); }
    function spawnHealing(x, y, z) {
        const p = new Particle(new THREE.Vector3(x, y, z), 0x00FF00, 0.1, 1.0, -2);
        p.vel.set((Math.random()-0.5)*2, 1.0, (Math.random()-0.5)*2);
        particles.push(p);
    }

    function findSafeSpawnAndStart() {
        let r = 0; let found = false;
        for(let i=0; i<50; i++) { if(getHeight(r, r) > 2.5) { found = true; break; } r += 20; }
        if(!found) r = 0;
        cameraLookAt.set(r, 0, r); updateCameraPosition(); updateChunks(); 
        createShaman(r, r); createWildmen(r, r);

        // Init Enemy
        enemyAI.init(-r - 40, -r - 40);
    }
    function createShaman(x, z) {
        const safe = findNearestLand(x, z);
        shaman = new Humanoid(0, 'shaman', safe.x, safe.z);
        units.push(shaman);
    }
    function createWildmen(cx, cz) {
        for(let i=0; i<6; i++) {
            let x = cx + (Math.random()-0.5)*30;
            let z = cz + (Math.random()-0.5)*30;
            const safe = findNearestLand(x, z);
            units.push(new Humanoid(0, 'wild', safe.x, safe.z));
        }
    }
    
    function updateUI() { document.getElementById('mana-text').innerText = Math.floor(mana); document.getElementById('mana-fill').style.width = mana + '%'; }

    // Input Handling
    function onPointerDown(e) {
        SoundManager.init();
        if(SoundManager.ctx.state === 'suspended') SoundManager.ctx.resume();
        isDragging = true; dragStart = {x: e.clientX, y: e.clientY}; tapStart = {x: e.clientX, y: e.clientY};
    }
    function onTouchStart(e) {
        e.preventDefault();
        if(e.touches.length === 1) onPointerDown(e.touches[0]);
        else if(e.touches.length === 2) {
            SoundManager.init();
            if(SoundManager.ctx.state === 'suspended') SoundManager.ctx.resume();
            isDragging = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            pinchStartDist = Math.sqrt(dx*dx+dy*dy);
            pinchStartScale = viewScale;
            pinchStartAngle = Math.atan2(dy, dx);
            rotateStartCamera = cameraRotation;
        }
    }
    function onPointerMove(e) { if(!isDragging) return; const dx = e.clientX - dragStart.x; const dy = e.clientY - dragStart.y; const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize(); const rgt = new THREE.Vector3(); rgt.crossVectors(fwd, camera.up); rgt.y = 0; rgt.normalize(); const speed = 0.002 * viewScale; cameraLookAt.addScaledVector(rgt, -dx * speed); cameraLookAt.addScaledVector(fwd, dy * speed); updateCameraPosition(); dragStart = {x: e.clientX, y: e.clientY}; }
    function onTouchMove(e) {
        if(e.touches.length === 1) {
            e.preventDefault();
            onPointerMove(e.touches[0]);
        } else if(e.touches.length === 2) {
            e.preventDefault();
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;

            // Zoom
            const dist = Math.sqrt(dx*dx+dy*dy);
            if(pinchStartDist > 0) {
                viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, pinchStartScale * (pinchStartDist / dist)));
            }

            // Rotate
            const currentAngle = Math.atan2(dy, dx);
            const delta = currentAngle - pinchStartAngle;
            cameraRotation = rotateStartCamera + delta;

            updateCameraZoom();
            updateCameraPosition();
        }
    }
    function onPointerUp(e) { isDragging = false; let x = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0); let y = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0); if(Math.sqrt((x-tapStart.x)**2 + (y-tapStart.y)**2) < 10) handleTap(x, y); }
    function handleTap(x, y) {
        const mouse = new THREE.Vector2((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
        raycaster.setFromCamera(mouse, camera);

        // Common: Get Terrain Point
        const meshes = [];
        for(let k in chunks) meshes.push(chunks[k].children[0]);
        const terrainHits = raycaster.intersectObjects(meshes);

        // Common: Get Unit Hits
        const unitMeshes = [];
        const meshToUnit = new Map();
        units.forEach(u => {
            if(u.state !== 'dead') {
                u.mesh.traverse(c => {
                     if(c.isMesh) {
                         unitMeshes.push(c);
                         meshToUnit.set(c, u);
                     }
                });
            }
        });
        const unitHits = raycaster.intersectObjects(unitMeshes);

        if (currentAction === 'select') {
            if (unitHits.length > 0) {
                const hitUnit = meshToUnit.get(unitHits[0].object);
                if(hitUnit) {
                    if(hitUnit.faction === 0) {
                        if(multiSelectMode) {
                            if(!selectedUnits.includes(hitUnit)) {
                                 selectedUnits.push(hitUnit);
                                 hitUnit.selectRing.visible = true;
                            } else {
                                 selectedUnits = selectedUnits.filter(u => u !== hitUnit);
                                 hitUnit.selectRing.visible = false;
                            }
                        } else {
                            selectedUnits.forEach(u => u.selectRing.visible = false);
                            selectedUnits = [hitUnit];
                            hitUnit.selectRing.visible = true;
                        }
                        updateContextMenus();
                        return;
                    }
                }
            }

            // If terrain clicked in select mode (and no unit hit)
            if(terrainHits.length > 0 && !multiSelectMode) {
                selectedUnits.forEach(u => u.selectRing.visible = false);
                selectedUnits = [];
                updateContextMenus();
            }
        } else {
            // Action Mode (Move, Spell, Build)
            if(currentAction === 'move' && unitHits.length > 0) {
                 const hitUnit = meshToUnit.get(unitHits[0].object);

                 // Enter Boat Logic
                 if(hitUnit && hitUnit.type === 'airship' && hitUnit.faction === 0) {
                     if(selectedUnits.length > 0) {
                         selectedUnits.forEach(u => {
                             if(u.type !== 'airship' && !u.isShaman) {
                                 u.goto(hitUnit.mesh.position.x, hitUnit.mesh.position.z);
                                 u.targetBoat = hitUnit;
                             }
                         });
                         spawnPulse(hitUnit.mesh.position.x, hitUnit.mesh.position.y, hitUnit.mesh.position.z, 0x00FF00);
                         return;
                     }
                 }

                 if(hitUnit && hitUnit.faction === 1) {
                     // Attack Logic
                     if(selectedUnits.length > 0) {
                        selectedUnits.forEach(u => {
                            if(!u.isShaman) {
                                u.attackTarget = hitUnit;
                                u.state = 'combat';
                            }
                        });
                        spawnPulse(hitUnit.mesh.position.x, hitUnit.mesh.position.y, hitUnit.mesh.position.z, 0xFF0000);
                        return;
                    }
                 }
            }

            if(terrainHits.length > 0) {
                 performAction(terrainHits[0].point.x, terrainHits[0].point.z);
            }
        }
    }
    function onWheel(e) { viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewScale + e.deltaY * 0.05)); updateCameraZoom(); updateCameraPosition(); }
    function updateCameraZoom() { const aspect = window.innerWidth / window.innerHeight; camera.left = -viewScale*aspect; camera.right = viewScale*aspect; camera.top = viewScale; camera.bottom = -viewScale; camera.updateProjectionMatrix(); }
    function updateCameraPosition() {
        const dist = 42.4;
        const offsetX = Math.sin(cameraRotation) * dist;
        const offsetZ = Math.cos(cameraRotation) * dist;
        const targetX = cameraLookAt.x + offsetX;
        const targetZ = cameraLookAt.z + offsetZ;
        let targetY = 25 + (viewScale / MAX_ZOOM) * 35;
        const groundUnderCamera = getHeight(targetX, targetZ);
        if(targetY < groundUnderCamera + 5) { targetY = groundUnderCamera + 5; }
        camera.position.set(targetX, targetY, targetZ);
        camera.lookAt(cameraLookAt);
    }
    function onResize() { updateCameraZoom(); renderer.setSize(window.innerWidth, window.innerHeight); }

    function animate() {
        requestAnimationFrame(animate); const dt = Math.min(clock.getDelta(), 0.1);
        // Mana Regeneration linked to population
        const playerBraves = units.filter(u => u.faction === 0 && u.type === 'wild').length;
        const manaRate = 1.0 + (playerBraves * 0.2); // Base + bonus per brave

        if (isNaN(mana)) mana = 0;
        if(mana < 100) { mana += dt * manaRate; if(isNaN(mana)) mana = 0; updateUI(); }

        if(chunkWaterMat && chunkWaterMat.uniforms) chunkWaterMat.uniforms.time.value += dt;

        updateChunks();
        enemyAI.update(dt);
        units.forEach(u => u.update(dt));
        buildings.forEach(b => b.update(dt));

        // Active Effects
        for(let i = activeEffects.length-1; i>=0; i--) {
            if(!activeEffects[i].update(dt)) activeEffects.splice(i, 1);
        }
        
        // Remove dead
        for(let i = buildings.length-1; i>=0; i--) { if(buildings[i].dead) buildings.splice(i, 1); }

        // Cleanup Dead Units
        for(let i = units.length-1; i>=0; i--) {
            if(units[i].state === 'dead') {
                if (units[i].deathTimer > 100) {
                     scene.remove(units[i].mesh);
                     units.splice(i, 1);
                }
            }
        }

        // Shaman Rebirth Logic (Player and Enemy)
        units.forEach(u => {
            if (u.isShaman && u.state === 'dead' && !u.respawnComplete) {
                if (!u.respawnPending) {
                    u.respawnPending = true;
                    u.respawnTimer = 30.0;
                } else {
                    u.respawnTimer -= dt;
                    if (u.respawnTimer <= 0) {
                        const braves = units.filter(b => b.faction === u.faction && b.type === 'wild' && b.state !== 'dead');
                        if (braves.length > 0) {
                            const brave = braves[Math.floor(Math.random() * braves.length)];
                            const safe = findNearestLand(brave.mesh.position.x, brave.mesh.position.z);

                            const newShaman = new Humanoid(u.faction, 'shaman', safe.x, safe.z);
                            units.push(newShaman);
                            spawnPulse(newShaman.mesh.position.x, newShaman.mesh.position.y, newShaman.mesh.position.z, 0xFFD700);
                            SoundManager.playSound('magic');

                            // If Player Shaman, update global reference
                            if (u.faction === 0) {
                                shaman = newShaman;
                            }

                            u.respawnComplete = true; // Mark old corpse as processed
                        } else {
                            // No followers left
                            if (u.faction === 0) {
                                // Game Over for Player
                                if(!window.gameOverAlertShown) {
                                    alert("GAME OVER - Shaman dead and no followers left.");
                                    window.gameOverAlertShown = true;
                                }
                                u.respawnTimer = 100000; // Prevent loop
                            } else {
                                // Enemy just stays dead
                                u.respawnComplete = true;
                            }
                        }
                    }
                }
            }
        });

        // Update Unit List
        const currentAlive = units.filter(u => u.state !== 'dead').length;
        if(currentAlive !== lastAliveCount) {
            updateUnitList();
            lastAliveCount = currentAlive;
        }
        updateUnitListSelection();

        for(let i = projectiles.length-1; i>=0; i--) { if(!projectiles[i].update(dt)) projectiles.splice(i, 1); }
        for(let i = particles.length-1; i>=0; i--) { if(!particles[i].update(dt)) particles.splice(i, 1); }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
