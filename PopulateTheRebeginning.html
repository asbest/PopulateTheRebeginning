<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Populate the Rebeginning</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-bar { padding: 10px; text-align: center; text-shadow: 1px 1px 2px black; pointer-events: auto; background: linear-gradient(to bottom, rgba(0,0,0,0.6), transparent);}
        h1 { margin: 0; font-size: 18px; color: #FFD700; text-transform: uppercase; letter-spacing: 2px; }
        p { margin: 5px 0 0; font-size: 12px; color: white; }

        /* TAB SYSTEM */
        #bottom-ui {
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            padding-bottom: 20px;
        }

        #tabs {
            display: flex; justify-content: center; gap: 20px; margin-bottom: 10px;
        }
        .tab-btn {
            width: 40px; height: 40px; border-radius: 50%; background: #444; border: 2px solid #888;
            color: white; font-size: 20px; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .tab-btn.active { background: #FFD700; color: black; border-color: white; box-shadow: 0 0 10px #FFD700; }

        #action-bar {
            display: flex; justify-content: center; gap: 10px; padding: 10px;
            flex-wrap: wrap;
            min-height: 80px;
        }

        .action-btn {
            width: 55px; height: 55px;
            border-radius: 50%;
            border: 3px solid #555;
            background: #222;
            color: white;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            position: relative;
        }
        .action-btn.active { border-color: #FFD700; transform: translateY(-5px); box-shadow: 0 0 15px #FFD700; background: #444; }
        .action-btn:active { transform: scale(0.95); }
        .label { font-size: 9px; position: absolute; bottom: -18px; width: 140%; left: -20%; text-align: center; text-shadow: 1px 1px 1px black; color: #ddd;}

        #mana-bar {
            width: 200px; height: 10px; background: #333; margin: 0 auto; border: 1px solid white; border-radius: 5px; overflow: hidden;
        }
        #mana-fill { width: 100%; height: 100%; background: #00BFFF; transition: width 0.2s; }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #FFD700; display: flex; align-items: center; justify-content: center;
            z-index: 100; font-size: 24px; font-weight: bold;
        }
    </style>
</head>
<body>

<div id="loading">Welt wird generiert...</div>

<div id="ui-layer">
    <div id="top-bar">
        <h1>Populous</h1>
        <div id="mana-bar"><div id="mana-fill"></div></div>
        <p>Mana: <span id="mana-text">100</span></p>
    </div>

    <div id="bottom-ui">
        <div id="tabs">
            <div class="tab-btn active" id="tab-spells" onclick="switchTab('spells')">‚ö°</div>
            <div class="tab-btn" id="tab-build" onclick="switchTab('build')">üî®</div>
            <div class="tab-btn" id="btn-multiselect" onclick="toggleMultiSelect()">‚äï</div>
        </div>
        
        <!-- Spells Menu -->
        <div id="menu-spells" class="action-menu">
            <div id="action-bar">
                <div class="action-btn active" onclick="selectAction('move')" id="btn-move">üë£<span class="label">Gehen</span></div>
                <div class="action-btn" onclick="selectAction('blast')" id="btn-blast">üî•<span class="label">Feuer (10)</span></div>
                <div class="action-btn" onclick="selectAction('raise')" id="btn-raise">‚ñ≤<span class="label">Heben (5)</span></div>
                <div class="action-btn" onclick="selectAction('lower')" id="btn-lower">‚ñº<span class="label">Senken (5)</span></div>
                <div class="action-btn" onclick="selectAction('volcano')" id="btn-volcano">üåã<span class="label">Vulkan (40)</span></div>
            </div>
        </div>

        <!-- Build Menu -->
        <div id="menu-build" class="action-menu" style="display:none;">
            <div id="action-bar">
                <div class="action-btn" onclick="selectAction('build_hut')" id="btn-build_hut">üè†<span class="label">H√ºtte (15)</span></div>
                <div class="action-btn" onclick="selectAction('build_tower')" id="btn-build_tower">üóº<span class="label">Turm (20)</span></div>
                <div class="action-btn" onclick="selectAction('build_warrior')" id="btn-build_warrior">‚öîÔ∏è<span class="label">Kaserne (30)</span></div>
                <div class="action-btn" onclick="selectAction('build_fire')" id="btn-build_fire">üî•<span class="label">Tempel (40)</span></div>
                <div class="action-btn" onclick="selectAction('build_spy')" id="btn-build_spy">üåô<span class="label">Geist (40)</span></div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
    // --- KONFIGURATION ---
    const CHUNK_SIZE = 40; 
    const CHUNK_RES = 40; 
    const RENDER_DISTANCE = 3;
    const NOISE_SCALE = 0.02;
    const MIN_ZOOM = 3;
    const MAX_ZOOM = 70;

    const COLORS = {
        water: 0x1E90FF, sand: 0xEEDC82, grass: 0x228B22, rock: 0x696969, snow: 0xFFFFFF,
        lava: 0xCF1020, skin: 0xD2B48C, shirt_wild: 0x8B4513, shirt_shaman: 0xFF4500,
        wood: 0x8B4513, straw: 0xDAA520, stone: 0x808080, red: 0x8B0000, yellow: 0xFFD700, blue: 0x4169E1
    };

    // --- GLOBALE SYSTEME ---
    let scene, camera, renderer, raycaster;
    let clock = new THREE.Clock();
    let simplex;
    
    // Spielzustand
    const chunks = {}; 
    const terrainMods = new Map();
    const units = [];
    const particles = [];
    const projectiles = [];
    const buildings = []; 
    
    let shaman;
    let selectedUnits = [];
    let cameraLookAt = new THREE.Vector3(0, 0, 0);
    let viewScale = 35; 
    let currentAction = 'move';
    let mana = 100;
    
    // Input
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let tapStart = { x: 0, y: 0 };
    let pinchStartDist = 0;
    let pinchStartScale = 35;
    let multiSelectMode = false;

    window.toggleMultiSelect = function() {
        multiSelectMode = !multiSelectMode;
        const btn = document.getElementById('btn-multiselect');
        if(multiSelectMode) {
             btn.classList.add('active');
             btn.style.boxShadow = '0 0 10px #00FF00';
             btn.style.borderColor = '#00FF00';
             btn.style.color = '#00FF00';
        } else {
             btn.classList.remove('active');
             btn.style.boxShadow = '';
             btn.style.borderColor = '#888';
             btn.style.color = 'white';
        }
    }

    // --- H√ñHEN-LOGIK ---
    function mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }

    function getBaseHeight(x, z) {
        if (!simplex) return 0;
        let y = 0;
        y += simplex.noise2D(x * NOISE_SCALE, z * NOISE_SCALE) * 12;
        y += simplex.noise2D(x * NOISE_SCALE * 2, z * NOISE_SCALE * 2) * 4;
        y += simplex.noise2D(x * NOISE_SCALE * 4, z * NOISE_SCALE * 4) * 1.5; 
        if (y < 2) y *= 0.8; 
        if (y > 8) y *= 1.2;
        return y;
    }

    function getHeight(x, z) {
        const ix = Math.round(x);
        const iz = Math.round(z);
        const key = `${ix},${iz}`;
        let h = getBaseHeight(x, z);
        if (terrainMods.has(key)) h += terrainMods.get(key);
        return h;
    }

    // --- INITIALISIERUNG ---
    window.onload = () => setTimeout(init, 100);

    function init() {
        document.getElementById('loading').style.display = 'none';
        
        simplex = new SimplexNoise(mulberry32(12345));

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -500, 1000);
        updateCameraZoom();
        
        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const amb = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(amb);
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(50, 100, 40);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
        sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
        sun.shadow.bias = -0.0005;
        scene.add(sun);

        raycaster = new THREE.Raycaster();

        findSafeSpawnAndStart();

        const c = renderer.domElement;
        c.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        c.addEventListener('touchstart', onTouchStart, {passive: false});
        window.addEventListener('touchmove', onTouchMove, {passive: false});
        window.addEventListener('touchend', onPointerUp);
        c.addEventListener('wheel', onWheel, {passive: false});
        window.addEventListener('resize', onResize);

        animate();
    }

    // --- UI SYSTEM ---
    window.switchTab = function(tab) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`tab-${tab}`).classList.add('active');
        document.querySelectorAll('.action-menu').forEach(m => m.style.display = 'none');
        document.getElementById(`menu-${tab}`).style.display = 'block';
    }

    window.selectAction = function(action) {
        currentAction = action;
        document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('active'));
        const btn = document.getElementById(`btn-${action}`);
        if(btn) btn.classList.add('active');
    }

    // --- AKTIONEN ---
    function performAction(x, z) {
        if(currentAction === 'move') {
            if(shaman && shaman.state !== 'dead') {
                shaman.goto(x, z);
                spawnPulse(x, getHeight(x, z), z, 0xFFFFFF);
            }
            return;
        }

        const costs = { 
            blast: 10, raise: 5, lower: 5, volcano: 40,
            build_hut: 15, build_tower: 20, build_warrior: 30, build_fire: 40, build_spy: 40 
        };
        if (mana < costs[currentAction]) return;
        mana -= costs[currentAction];
        updateUI();

        if (currentAction === 'blast') {
            const startPos = shaman.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            const h = getHeight(x, z);
            const targetPos = new THREE.Vector3(x, h, z);
            projectiles.push(new Fireball(startPos, targetPos));
            
            const dx = targetPos.x - shaman.mesh.position.x;
            const dz = targetPos.z - shaman.mesh.position.z;
            shaman.mesh.rotation.y = Math.atan2(dx, dz);
        }
        else if (currentAction === 'raise') {
            modifyTerrain(x, z, 5, 2.0); 
            spawnExplosion(x, getHeight(x, z), z, 0x00FF00, 10);
        }
        else if (currentAction === 'lower') {
            modifyTerrain(x, z, 5, -2.0);
            spawnExplosion(x, getHeight(x, z), z, 0x0000FF, 10);
        }
        else if (currentAction === 'volcano') {
            createVolcano(x, z);
        }
        else if (currentAction.startsWith('build_')) {
            const type = currentAction.replace('build_', '');
            createBuilding(type, x, z);
        }
    }

    // --- GEB√ÑUDE SYSTEM ---
    function createBuilding(type, x, z, faction = 0) {
        const baseH = getHeight(x, z);
        const radius = 3;
        
        // Auto-Planierung
        for(let ix = Math.floor(x - radius); ix <= Math.ceil(x + radius); ix++) {
            for(let iz = Math.floor(z - radius); iz <= Math.ceil(z + radius); iz++) {
                const dist = Math.sqrt((ix-x)**2 + (iz-z)**2);
                if(dist <= radius) {
                    const key = `${ix},${iz}`;
                    const naturalH = getBaseHeight(ix, iz);
                    const targetMod = baseH - naturalH;
                    terrainMods.set(key, targetMod); 
                }
            }
        }
        updateChunks(true); 

        const group = new THREE.Group();
        group.position.set(x, baseH, z);
        
        let mesh, maxHp;
        if (type === 'hut') { mesh = buildHut(); maxHp = 100; }
        else if (type === 'tower') { mesh = buildTower(); maxHp = 150; }
        else if (type === 'warrior') { mesh = buildBarracks(); maxHp = 250; }
        else if (type === 'fire') { mesh = buildFireTemple(); maxHp = 300; }
        else if (type === 'spy') { mesh = buildSpyHut(); maxHp = 200; }
        
        if(mesh) {
            group.add(mesh);
            
            // HP Bar f√ºr Geb√§ude
            const hpGroup = new THREE.Group();
            hpGroup.position.set(0, 5, 0); // Hoch √ºber dem Geb√§ude
            const bgMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 0.3), new THREE.MeshBasicMaterial({color: 0x880000}));
            hpGroup.add(bgMesh);
            const fgGeo = new THREE.PlaneGeometry(2.0, 0.3); fgGeo.translate(1.0, 0, 0); 
            const hpBar = new THREE.Mesh(fgGeo, new THREE.MeshBasicMaterial({color: 0x00FF00}));
            hpBar.position.x = -1.0;
            hpGroup.add(hpBar);
            group.add(hpGroup);

            scene.add(group);
            
            const building = { 
                mesh: group, 
                hpBar: hpBar,
                hpGroup: hpGroup,
                type: type, 
                faction: faction,
                hp: maxHp, 
                maxHp: maxHp,
                takeDamage: function(amount) {
                    this.hp -= amount;
                    this.hpBar.scale.x = Math.max(0, this.hp / this.maxHp);
                    spawnPulse(this.mesh.position.x, this.mesh.position.y + 2, this.mesh.position.z, 0xFF4500);
                    if(this.hp <= 0) {
                        this.destroy();
                    }
                },
                destroy: function() {
                    this.dead = true;
                    scene.remove(this.mesh);
                    spawnExplosion(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, COLORS.wood, 20);
                },
                update: function(dt) {
                    this.hpGroup.lookAt(camera.position);
                    if(this.training) {
                        this.trainTimer -= dt;
                        if(this.trainTimer <= 0) {
                            this.training = false;
                            const u = new Humanoid(this.trainFaction, this.trainType, this.mesh.position.x + 2, this.mesh.position.z + 2);
                            units.push(u);
                            spawnPulse(u.mesh.position.x, u.mesh.position.y, u.mesh.position.z, 0xFFD700);
                        }
                    }
                }
            };
            
            buildings.push(building);
            spawnExplosion(x, baseH, z, 0xFFD700, 15);
            
            if(type === 'hut') {
                setTimeout(() => {
                    if(!building.dead) {
                        // Assuming building belongs to player for now. Enemy AI will need its own building creation logic.
                        // Or we infer faction from proximity or store faction in building.
                        // For simplicity, let's assume buildings created via UI are Player (0).
                        const u = new Humanoid(faction, 'wild', x+2, z+2);
                        units.push(u);
                        spawnPulse(x+2, baseH, z+2, 0xFFFFFF);
                    }
                }, 2000);
            }
        }
    }

    // --- GEB√ÑUDE MODELLE ---
    function buildHut() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.4, 1.5, 8), new THREE.MeshLambertMaterial({color: COLORS.wood})); base.position.y = 0.75; base.castShadow = true; g.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.8, 1.5, 8), new THREE.MeshLambertMaterial({color: COLORS.straw})); roof.position.y = 1.5 + 0.75; roof.castShadow = true; g.add(roof);
        const door = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.2), new THREE.MeshLambertMaterial({color: 0x220000})); door.position.set(0, 0.5, 1.2); g.add(door);
        return g;
    }
    function buildTower() {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1.0, 4, 6), new THREE.MeshLambertMaterial({color: COLORS.wood})); body.position.y = 2; body.castShadow = true; g.add(body);
        const plat = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.2, 0.5, 6), new THREE.MeshLambertMaterial({color: COLORS.wood})); plat.position.y = 3.8; g.add(plat);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1.0, 6), new THREE.MeshLambertMaterial({color: COLORS.straw})); roof.position.y = 4.5; g.add(roof);
        return g;
    }
    function buildBarracks() {
        const g = new THREE.Group();
        const walls = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 2), new THREE.MeshLambertMaterial({color: COLORS.stone})); walls.position.y = 0.75; walls.castShadow = true; g.add(walls);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(2.2, 1.5, 4), new THREE.MeshLambertMaterial({color: COLORS.red})); roof.position.y = 1.5 + 0.75; roof.rotation.y = Math.PI/4; roof.scale.set(1, 1, 0.7); g.add(roof);
        return g;
    }
    function buildFireTemple() {
        const g = new THREE.Group();
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 1.2, 8), new THREE.MeshLambertMaterial({color: 0x444444})); base.position.y = 0.6; g.add(base);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(1.8, 2, 8), new THREE.MeshLambertMaterial({color: COLORS.yellow})); roof.position.y = 1.2 + 1; g.add(roof);
        return g;
    }
    function buildSpyHut() {
        const g = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 3, 1.2), new THREE.MeshLambertMaterial({color: 0x222222})); body.position.y = 1.5; g.add(body);
        const roof = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), new THREE.MeshLambertMaterial({color: COLORS.blue, emissive: 0x000044})); roof.position.y = 3.2; g.add(roof);
        return g;
    }

    // --- TERRAIN FUNKTIONEN ---
    function modifyTerrain(centerX, centerZ, radius, amount) {
        const rSq = radius * radius;
        const modifiedChunks = new Set();
        for(let x = Math.floor(centerX - radius); x <= Math.ceil(centerX + radius); x++) {
            for(let z = Math.floor(centerZ - radius); z <= Math.ceil(centerZ + radius); z++) {
                const distSq = (x - centerX)**2 + (z - centerZ)**2;
                if (distSq <= rSq) {
                    const falloff = 1 - (distSq / rSq);
                    const key = `${x},${z}`;
                    const currentMod = terrainMods.get(key) || 0;
                    terrainMods.set(key, currentMod + (amount * falloff));
                    const cx = Math.round(x / CHUNK_SIZE);
                    const cz = Math.round(z / CHUNK_SIZE);
                    modifiedChunks.add(`${cx},${cz}`);
                }
            }
        }
        updateChunks(true);
        // Pr√ºfen ob Geb√§ude einst√ºrzen
        buildings.forEach(b => {
            const groundH = getHeight(b.mesh.position.x, b.mesh.position.z);
            if(Math.abs(groundH - b.mesh.position.y) > 1.0) {
                b.takeDamage(100); // Einsturzschaden
            }
        });
    }

    function createVolcano(x, z) {
        const radius = 12;
        modifyTerrain(x, z, radius, 15);
        setTimeout(() => {
            modifyTerrain(x, z, 3, -8); 
            spawnExplosion(x, getHeight(x,z), z, COLORS.lava, 50);
            
            // Einheiten
            units.forEach(u => {
                const dist = u.mesh.position.distanceTo(new THREE.Vector3(x, u.mesh.position.y, z));
                if(dist < radius + 5) {
                    const dir = u.mesh.position.clone().sub(new THREE.Vector3(x, u.mesh.position.y, z)).normalize();
                    u.applyForce(dir.multiplyScalar(35).add(new THREE.Vector3(0, 25, 0)));
                    if (!u.isShaman) { u.takeDamage(100); }
                }
            });
            // Geb√§ude
            buildings.forEach(b => {
                const dist = b.mesh.position.distanceTo(new THREE.Vector3(x, b.mesh.position.y, z));
                if(dist < radius + 5) {
                    b.takeDamage(1000); // Sofortige Zerst√∂rung
                }
            });

        }, 200);
    }

    function updateChunks(force = false) {
        const cx = Math.round(cameraLookAt.x / CHUNK_SIZE);
        const cz = Math.round(cameraLookAt.z / CHUNK_SIZE);
        const activeKeys = new Set();
        for(let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
            for(let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                const key = (cx+x) + "," + (cz+z);
                activeKeys.add(key);
                if(!chunks[key] || force) { 
                    if(chunks[key]) {
                        scene.remove(chunks[key]);
                        chunks[key].children.forEach(m=>{ if(m.geometry) m.geometry.dispose(); if(m.material) m.material.dispose(); });
                    }
                    chunks[key] = createChunk(cx+x, cz+z); 
                    scene.add(chunks[key]); 
                }
            }
        }
        if(!force) {
            for(let key in chunks) {
                if(!activeKeys.has(key)) {
                    scene.remove(chunks[key]);
                    delete chunks[key];
                }
            }
        }
    }

    function createChunk(cx, cz) {
        const grp = new THREE.Group();
        const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, CHUNK_RES, CHUNK_RES);
        geo.rotateX(-Math.PI/2);
        const pos = geo.attributes.position;
        const colors = []; const col = new THREE.Color();
        const offX = cx * CHUNK_SIZE; const offZ = cz * CHUNK_SIZE;
        for(let i=0; i<pos.count; i++) {
            const wx = pos.getX(i) + offX; const wz = pos.getZ(i) + offZ;
            let h = getHeight(wx, wz);
            pos.setY(i, h);
            if(h < 0.5) col.setHex(COLORS.water); else if(h < 2.5) col.setHex(COLORS.sand);
            else if(h < 9) col.setHex(COLORS.grass); else if(h < 14) col.setHex(COLORS.rock);
            else if(h > 20) col.setHex(COLORS.lava); else col.setHex(COLORS.snow);
            if(h > 2.5) col.offsetHSL(0, 0, (Math.random()-0.5)*0.03);
            colors.push(col.r, col.g, col.b);
        }
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.computeVertexNormals();
        const mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ vertexColors: true, flatShading: true }));
        mesh.position.set(offX, 0, offZ); mesh.receiveShadow = true;
        grp.add(mesh);
        const wMesh = new THREE.Mesh(new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE), new THREE.MeshBasicMaterial({color: COLORS.water, transparent: true, opacity: 0.6}));
        wMesh.rotation.x = -Math.PI/2; wMesh.position.set(offX, 0.5, offZ);
        grp.add(wMesh);
        if(Math.random() > 0.5) { 
             const lx = (Math.random()-0.5)*CHUNK_SIZE; const lz = (Math.random()-0.5)*CHUNK_SIZE;
             const h = getHeight(lx+offX, lz+offZ);
             if(h > 3 && h < 8) {
                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.25,1,5), new THREE.MeshLambertMaterial({color:0x8B4513}));
                t.position.set(lx+offX, h+0.5, lz+offZ); t.castShadow = true;
                const l = new THREE.Mesh(new THREE.ConeGeometry(0.9,2.8,5), new THREE.MeshLambertMaterial({color:0x006400}));
                l.position.set(lx+offX, h+1.9, lz+offZ); l.castShadow = true;
                grp.add(t); grp.add(l);
             }
        }
        return grp;
    }

    // --- CHARAKTER & PHYSIK ---
    class Humanoid {
        constructor(faction, type, x, z) {
            this.faction = faction; // 0 = Player, 1 = Enemy
            this.type = type; // 'wild', 'warrior', 'firewarrior', 'spy', 'shaman'
            this.isShaman = (type === 'shaman');

            // Stats
            this.maxHp = 100; this.damage = 5; this.range = 1; this.attackSpeed = 1.0; this.moveSpeed = 6;
            if(type === 'warrior') { this.maxHp = 200; this.damage = 15; }
            if(type === 'firewarrior') { this.maxHp = 120; this.damage = 25; this.range = 12; this.attackSpeed = 2.0; }
            if(type === 'shaman') { this.maxHp = 500; this.damage = 30; this.range = 15; }

            this.hp = this.maxHp; this.recoverTimer = 0;

            // Visuals
            this.mesh = new THREE.Group();
            const color = faction === 0 ? COLORS.blue : COLORS.red;
            const skinMat = new THREE.MeshLambertMaterial({color: COLORS.skin});
            const shirtMat = new THREE.MeshLambertMaterial({color: color});
            
            // Selection Ring
            this.selectRing = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 16), new THREE.MeshBasicMaterial({color: 0x00FF00, side: THREE.DoubleSide}));
            this.selectRing.rotation.x = -Math.PI/2; this.selectRing.visible = false; this.mesh.add(this.selectRing);

            // HP Bar
            this.hpGroup = new THREE.Group(); this.hpGroup.position.set(0, 2.3, 0);
            this.hpGroup.add(new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.15), new THREE.MeshBasicMaterial({color: 0x880000})));
            const fgGeo = new THREE.PlaneGeometry(1.0, 0.15); fgGeo.translate(0.5, 0, 0); 
            this.hpBar = new THREE.Mesh(fgGeo, new THREE.MeshBasicMaterial({color: faction === 0 ? 0x00FF00 : 0xFF0000}));
            this.hpBar.position.x = -0.5; this.hpGroup.add(this.hpBar);
            this.mesh.add(this.hpGroup);

            // Body Parts
            this.torso = new THREE.Group(); this.torso.position.y = 0.9; this.mesh.add(this.torso);
            this.torso.add(new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.25), shirtMat));
            this.head = new THREE.Group(); this.head.position.y = 0.4; this.torso.add(this.head);
            this.head.add(new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.3), skinMat));

            // Props
            if(this.isShaman) {
                const mask = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.1), new THREE.MeshLambertMaterial({color: 0xFFD700}));
                mask.position.z = 0.16; this.head.add(mask);
                const hornGeo = new THREE.ConeGeometry(0.04, 0.3, 4);
                const h1 = new THREE.Mesh(hornGeo, new THREE.MeshLambertMaterial({color:0xFFFFFF})); h1.position.set(0.15, 0.2, 0); h1.rotation.z = -0.3;
                const h2 = h1.clone(); h2.position.set(-0.15, 0.2, 0); h2.rotation.z = 0.3; this.head.add(h1); this.head.add(h2);
            } else if (type === 'warrior') {
                const helm = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8, 0, Math.PI * 2, 0, Math.PI/2), new THREE.MeshLambertMaterial({color: 0x555555}));
                helm.position.y = 0.1; this.head.add(helm);
            } else if (type === 'firewarrior') {
                const mask = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.1), new THREE.MeshLambertMaterial({color: 0xFF4500}));
                mask.position.z = 0.16; this.head.add(mask);
            }

            const createLimb = (w, h, mat, px, py, pz) => {
                const group = new THREE.Group(); group.position.set(px, py, pz);
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), mat); mesh.position.y = -h / 2; mesh.castShadow = true;
                group.add(mesh); return group;
            };
            this.armL = createLimb(0.12, 0.45, skinMat, 0.26, 0.15, 0);
            this.armR = createLimb(0.12, 0.45, skinMat, -0.26, 0.15, 0);
            this.torso.add(this.armL); this.torso.add(this.armR);

            // Weapons
            if(type === 'warrior') {
                const sword = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.6, 0.1), new THREE.MeshLambertMaterial({color: 0xDDDDDD}));
                sword.position.y = -0.3; sword.position.z = 0.1; sword.rotation.x = Math.PI/2;
                this.armR.children[0].add(sword);
            }

            this.legL = createLimb(0.13, 0.55, shirtMat, 0.1, 0.65, 0);
            this.legR = createLimb(0.13, 0.55, shirtMat, -0.1, 0.65, 0);
            this.mesh.add(this.legL); this.mesh.add(this.legR);

            this.mesh.position.set(x, getHeight(x,z), z);
            scene.add(this.mesh);
            this.velocity = new THREE.Vector3(0,0,0);
            this.isGrounded = true; this.target = null; this.attackTarget = null; this.state = 'idle'; this.animTime = Math.random() * 100;
            this.lastAttackTime = 0;
        }

        lookAtTarget(pos) {
            const dx = pos.x - this.mesh.position.x;
            const dz = pos.z - this.mesh.position.z;
            this.mesh.rotation.y = Math.atan2(dx, dz);
        }

        takeDamage(amount) {
            if(this.state === 'dead') return;
            this.hp -= amount;
            this.hpBar.scale.x = Math.max(0, this.hp / this.maxHp);
            spawnPulse(this.mesh.position.x, this.mesh.position.y + 1, this.mesh.position.z, 0xFF0000);
            if(this.hp <= 0) this.die();
        }

        die() {
            this.state = 'dead'; this.hpGroup.visible = false; this.velocity.set(0, 0, 0);
        }
        
        applyForce(vec) {
            if(this.state === 'dead') return;
            this.velocity.add(vec); this.isGrounded = false; this.state = 'stunned'; this.recoverTimer = 2.0; this.target = null;
        }

        goto(x, z) {
            if(this.state === 'stunned' || this.state === 'dead') return;
            this.target = new THREE.Vector3(x, 0, z); this.state = 'move';
        }
        
        findTarget() {
             // Find closest enemy
             let minDist = 1000;
             let closest = null;
             units.forEach(u => {
                 if(u.faction !== this.faction && u.state !== 'dead') {
                     const d = this.mesh.position.distanceTo(u.mesh.position);
                     if(d < 30 && d < minDist) {
                         minDist = d; closest = u;
                     }
                 }
             });
             // Also check for buildings?
             return closest;
        }

        attack() {
            if(!this.attackTarget || this.attackTarget.state === 'dead') {
                 this.state = 'idle'; this.attackTarget = null; return;
            }

            this.mesh.lookAt(this.attackTarget.mesh.position.x, this.mesh.position.y, this.attackTarget.mesh.position.z);

            // Animation
            const t = this.animTime * 10;
            this.armR.rotation.x = -Math.PI/2 + Math.sin(t) * 0.5; // Swing

            // Deal damage at right time
            // Simplified: just check cooldown
            if(clock.getElapsedTime() - this.lastAttackTime > (1.0/this.attackSpeed)) {
                this.lastAttackTime = clock.getElapsedTime();
                if(this.type === 'firewarrior') {
                    // Spawn Fireball
                     const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                     const targetPos = this.attackTarget.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
                     projectiles.push(new Fireball(startPos, targetPos));
                } else {
                    // Melee
                    this.attackTarget.takeDamage(this.damage);
                }
            }
        }

        update(dt) {
            this.hpGroup.lookAt(camera.position); this.animTime += dt;
            if(!this.isGrounded) this.velocity.y -= 30 * dt; 
            else { this.velocity.x *= 0.9; this.velocity.z *= 0.9; }
            this.mesh.position.addScaledVector(this.velocity, dt);

            const groundH = getHeight(this.mesh.position.x, this.mesh.position.z);
            if (this.mesh.position.y < groundH) {
                if(this.velocity.y < -15 && this.state !== 'dead' && !this.isShaman) this.takeDamage(10);
                this.mesh.position.y = groundH + 0.35; 
                this.isGrounded = true; this.velocity.y = 0;
                if(this.state === 'stunned' && this.velocity.length() < 1) { this.state = 'idle'; this.mesh.rotation.z = 0; this.mesh.rotation.x = 0; }
            } else if (this.mesh.position.y > groundH + 0.35) { this.isGrounded = false; }

            // Building Entry Check for Training
            if(this.type === 'wild' && this.state !== 'dead' && this.faction === 0) {
                 buildings.forEach(b => {
                     // Check if building is ready to train?
                     // For now instant training logic
                     const dist = this.mesh.position.distanceTo(b.mesh.position);
                     if(dist < 2.0 && b.hp > 0 && !b.training) {
                         let newType = null;
                         if(b.type === 'warrior') newType = 'warrior';
                         if(b.type === 'fire') newType = 'firewarrior';
                         if(b.type === 'spy') newType = 'spy'; // not implemented fully visual wise but logic is here

                         if(newType) {
                             // Enter building
                             this.die(); // Remove old unit
                             scene.remove(this.mesh); // Hide immediately
                             this.hp = 0; // Ensure cleaned up

                             // Start training timer on building
                             b.training = true;
                             b.trainTimer = 2.0;
                             b.trainType = newType;
                             b.trainFaction = this.faction;
                             spawnPulse(b.mesh.position.x, b.mesh.position.y+2, b.mesh.position.z, 0x00FF00);
                         }
                     }
                 });
            }

            if (this.state === 'dead') {
                if(this.mesh.rotation.x > -Math.PI/2) this.mesh.rotation.x -= dt * 5;
                if(this.mesh.position.y > groundH - 0.2) this.mesh.position.y -= dt * 0.1;
                return; 
            }
            if(this.state === 'stunned') {
                if(this.velocity.length() > 2 || !this.isGrounded) {
                     this.mesh.rotation.x += dt * 5; this.mesh.rotation.z += dt * 3;
                     this.legL.rotation.x = Math.sin(this.animTime * 15); this.legR.rotation.x = Math.sin(this.animTime * 15 + Math.PI);
                     this.armL.rotation.x = Math.sin(this.animTime * 15); this.armR.rotation.x = Math.sin(this.animTime * 15 + Math.PI);
                } else {
                    this.recoverTimer -= dt;
                    const targetRotX = -Math.PI/2;
                    this.mesh.rotation.x += (targetRotX - this.mesh.rotation.x) * 5 * dt;
                    this.mesh.rotation.z *= 0.9; 
                    this.resetAnim();
                    if(this.recoverTimer <= 0) { this.state = 'idle'; this.mesh.rotation.x = 0; }
                }
            }
            else if(this.state === 'combat') {
                if(!this.attackTarget || this.attackTarget.state === 'dead') {
                    // Try find new target
                    this.attackTarget = this.findTarget();
                    if(!this.attackTarget) { this.state = 'idle'; return; }
                }

                const dist = this.mesh.position.distanceTo(this.attackTarget.mesh.position);
                if(dist <= this.range) {
                    // In range, attack
                    this.velocity.set(0,0,0);
                    this.attack();
                } else {
                    // Move towards
                    const dx = this.attackTarget.mesh.position.x - this.mesh.position.x;
                    const dz = this.attackTarget.mesh.position.z - this.mesh.position.z;
                    const dir = new THREE.Vector3(dx, 0, dz).normalize();
                    const speed = this.moveSpeed;
                    this.velocity.x = dir.x * speed; this.velocity.z = dir.z * speed;
                    this.mesh.rotation.y = Math.atan2(dx, dz);

                    // Walk Anim
                    const walkSpeed = 10; const amp = 0.8;
                    this.legL.rotation.x = Math.sin(this.animTime * walkSpeed) * amp;
                    this.legR.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp;
                    this.armL.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp * 0.6;
                    this.armR.rotation.x = Math.sin(this.animTime * walkSpeed) * amp * 0.6;
                }
            }
            else if(this.state === 'move' && this.target && this.isGrounded) {
                const dx = this.target.x - this.mesh.position.x;
                const dz = this.target.z - this.mesh.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                if(dist < 0.5) { this.state = 'idle'; this.velocity.set(0,0,0); this.resetAnim(); } 
                else {
                    const speed = this.moveSpeed;
                    const dir = new THREE.Vector3(dx, 0, dz).normalize();
                    this.velocity.x = dir.x * speed; this.velocity.z = dir.z * speed;
                    this.mesh.rotation.y = Math.atan2(dx, dz); 
                    this.mesh.rotation.x = 0; this.mesh.rotation.z = 0;
                    const walkSpeed = 10; const amp = 0.8; 
                    this.legL.rotation.x = Math.sin(this.animTime * walkSpeed) * amp;
                    this.legR.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp;
                    this.armL.rotation.x = Math.sin(this.animTime * walkSpeed + Math.PI) * amp * 0.6;
                    this.armR.rotation.x = Math.sin(this.animTime * walkSpeed) * amp * 0.6;
                    this.torso.position.y = 0.9 + Math.abs(Math.sin(this.animTime * walkSpeed)) * 0.05;
                }
            } else {
                // Idle Check Aggro
                if(this.type !== 'wild') { // Braves don't auto aggro usually? Or do they? In Populous they flee.
                    // For now, only warriors/shamans auto aggro
                    const target = this.findTarget();
                    if(target) {
                        this.attackTarget = target;
                        this.state = 'combat';
                    }
                }

                this.resetAnim();
                this.torso.position.y = 0.9 + Math.sin(this.animTime * 2) * 0.02;
                this.armL.rotation.z = Math.sin(this.animTime) * 0.05 + 0.1;
                this.armR.rotation.z = -Math.sin(this.animTime) * 0.05 - 0.1;
                this.mesh.rotation.x *= 0.8; this.mesh.rotation.z *= 0.8;
            }
        }
        resetAnim() {
            const lerp = 0.1;
            this.legL.rotation.x += (0 - this.legL.rotation.x) * lerp;
            this.legR.rotation.x += (0 - this.legR.rotation.x) * lerp;
            this.armL.rotation.x += (0 - this.armL.rotation.x) * lerp;
            this.armR.rotation.x += (0 - this.armR.rotation.x) * lerp;
        }
    }

    // --- ENEMY AI ---
    class EnemyAI {
        constructor() {
            this.timer = 0;
            this.state = 'build'; // 'build', 'attack'
            this.baseX = 0;
            this.baseZ = 0;
        }

        init(x, z) {
            this.baseX = x;
            this.baseZ = z;
            // Create initial base
            createBuilding('hut', x, z, 1);
            // Create some units
            for(let i=0; i<3; i++) {
                units.push(new Humanoid(1, 'wild', x + (Math.random()-0.5)*5, z + (Math.random()-0.5)*5));
            }
            // Create a tower
            createBuilding('tower', x + 5, z + 5, 1);
        }

        update(dt) {
            this.timer += dt;
            if(this.timer > 5.0) {
                this.timer = 0;
                this.think();
            }
        }

        think() {
            // Get Enemy Units
            const myUnits = units.filter(u => u.faction === 1 && u.state !== 'dead');
            const myBuildings = buildings.filter(b => true); // Need faction on buildings really.
            // For now assume buildings near base are mine.

            // 1. Train Units
            // If I have Braves and Buildings, train.
            // Simplified: Just spawn occasionally for challenge.
            if(Math.random() < 0.3) {
                 const type = Math.random() > 0.5 ? 'warrior' : 'firewarrior';
                 units.push(new Humanoid(1, type, this.baseX + (Math.random()-0.5)*10, this.baseZ + (Math.random()-0.5)*10));
            }

            // 2. Attack Player
            if(myUnits.length > 5) {
                // Send some to attack player shaman
                const attackers = myUnits.filter(u => u.type !== 'wild' && u.state === 'idle');
                const target = shaman;
                if(target && target.state !== 'dead') {
                    attackers.forEach(u => {
                        u.goto(target.mesh.position.x, target.mesh.position.z);
                        u.attackTarget = target;
                        u.state = 'combat'; // Force combat state approach
                    });
                }
            }
        }
    }
    const enemyAI = new EnemyAI();

    // --- HELFER KLASSEN (Partikel, Feuerball) ---
    class Particle {
        constructor(pos, color, size, life) {
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshBasicMaterial({color: color}));
            this.mesh.position.copy(pos);
            this.vel = new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10+5, (Math.random()-0.5)*10);
            this.life = life; scene.add(this.mesh);
        }
        update(dt) {
            this.vel.y -= 20 * dt; this.mesh.position.addScaledVector(this.vel, dt);
            this.mesh.rotation.x += dt*2; this.mesh.rotation.y += dt*2; this.life -= dt;
            const h = getHeight(this.mesh.position.x, this.mesh.position.z);
            if(this.mesh.position.y < h) { this.mesh.position.y = h; this.vel.y *= -0.5; this.vel.x *= 0.8; this.vel.z *= 0.8; }
            if(this.life <= 0) { scene.remove(this.mesh); return false; } return true;
        }
    }

    class Fireball {
        constructor(start, end) {
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({color: 0xFF4500}));
            this.mesh.position.copy(start); this.target = end; this.dir = end.clone().sub(start).normalize();
            this.speed = 25; this.active = true; this.trailTimer = 0; scene.add(this.mesh);
        }
        update(dt) {
            if(!this.active) return false;
            this.mesh.position.addScaledVector(this.dir, this.speed * dt); this.trailTimer += dt;
            if(this.trailTimer > 0.05) { particles.push(new Particle(this.mesh.position, 0xFFA500, 0.2, 0.5)); this.trailTimer = 0; }
            const dist = this.mesh.position.distanceTo(this.target);
            if(dist < 1.0 || getHeight(this.mesh.position.x, this.mesh.position.z) > this.mesh.position.y) { this.explode(); return false; } return true;
        }
        explode() {
            scene.remove(this.mesh); this.active = false;
            spawnExplosion(this.mesh.position.x, this.mesh.position.y, this.mesh.position.z, 0xFF4500, 20);
            const impactPos = this.mesh.position;
            // Einheiten
            units.forEach(u => {
                const d = u.mesh.position.distanceTo(impactPos);
                if(d < 8) {
                    if (!u.isShaman) {
                        const forceDir = u.mesh.position.clone().sub(impactPos).normalize(); const force = (8 - d) * 3;
                        forceDir.multiplyScalar(force); forceDir.y += force * 0.5;
                        u.applyForce(forceDir); u.takeDamage(9);
                    }
                }
            });
            // Geb√§ude
            buildings.forEach(b => {
                const d = b.mesh.position.distanceTo(impactPos);
                if(d < 8) {
                    b.takeDamage(25); // Feuerball macht 25 Schaden an Geb√§uden
                }
            });
        }
    }

    function spawnExplosion(x, y, z, color, count) { for(let i=0; i<count; i++) particles.push(new Particle(new THREE.Vector3(x, y, z), color, 0.3+Math.random()*0.3, 1.0+Math.random())); }
    function spawnPulse(x, y, z, color) { particles.push(new Particle(new THREE.Vector3(x, y+0.5, z), color, 0.2, 0.5)); }

    function findSafeSpawnAndStart() {
        let r = 0; let found = false;
        for(let i=0; i<50; i++) { if(getHeight(r, r) > 2.5) { found = true; break; } r += 20; }
        if(!found) r = 0;
        cameraLookAt.set(r, 0, r); updateCameraPosition(); updateChunks(); 
        createShaman(r, r); createWildmen(r, r);

        // Init Enemy
        enemyAI.init(-r - 40, -r - 40);
    }
    function createShaman(x, z) { shaman = new Humanoid(0, 'shaman', x, z); units.push(shaman); }
    function createWildmen(cx, cz) { for(let i=0; i<6; i++) { let x = cx + (Math.random()-0.5)*30; let z = cz + (Math.random()-0.5)*30; if(getHeight(x, z) > 2.5) units.push(new Humanoid(0, 'wild', x, z)); } }
    
    function updateUI() { document.getElementById('mana-text').innerText = Math.floor(mana); document.getElementById('mana-fill').style.width = mana + '%'; }

    // Input Handling
    function onPointerDown(e) { isDragging = true; dragStart = {x: e.clientX, y: e.clientY}; tapStart = {x: e.clientX, y: e.clientY}; }
    function onTouchStart(e) { e.preventDefault(); if(e.touches.length === 1) onPointerDown(e.touches[0]); else if(e.touches.length === 2) { isDragging = false; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; pinchStartDist = Math.sqrt(dx*dx+dy*dy); pinchStartScale = viewScale; } }
    function onPointerMove(e) { if(!isDragging) return; const dx = e.clientX - dragStart.x; const dy = e.clientY - dragStart.y; const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize(); const rgt = new THREE.Vector3(); rgt.crossVectors(fwd, camera.up); rgt.y = 0; rgt.normalize(); const speed = 0.002 * viewScale; cameraLookAt.addScaledVector(rgt, -dx * speed); cameraLookAt.addScaledVector(fwd, dy * speed); updateCameraPosition(); dragStart = {x: e.clientX, y: e.clientY}; }
    function onTouchMove(e) { if(e.touches.length === 1) { e.preventDefault(); onPointerMove(e.touches[0]); } else if(e.touches.length === 2) { e.preventDefault(); const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const dist = Math.sqrt(dx*dx+dy*dy); if(pinchStartDist > 0) { viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, pinchStartScale * (pinchStartDist / dist))); updateCameraZoom(); updateCameraPosition(); } } }
    function onPointerUp(e) { isDragging = false; let x = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0); let y = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0); if(Math.sqrt((x-tapStart.x)**2 + (y-tapStart.y)**2) < 10) handleTap(x, y); }
    function handleTap(x, y) {
        const mouse = new THREE.Vector2((x/window.innerWidth)*2-1, -(y/window.innerHeight)*2+1);
        raycaster.setFromCamera(mouse, camera);

        // 1. Check for Unit Clicks
        const unitMeshes = [];
        const meshToUnit = new Map();
        units.forEach(u => {
            if(u.state !== 'dead') {
                u.mesh.traverse(c => {
                     if(c.isMesh) {
                         unitMeshes.push(c);
                         meshToUnit.set(c, u);
                     }
                });
            }
        });

        const unitHits = raycaster.intersectObjects(unitMeshes);
        if (unitHits.length > 0) {
            const hitUnit = meshToUnit.get(unitHits[0].object);
            if(hitUnit) {
                if(hitUnit.faction === 0) {
                    // Toggle Selection for Player Units
                    if(!selectedUnits.includes(hitUnit)) {
                         selectedUnits.push(hitUnit);
                         hitUnit.selectRing.visible = true;
                    } else {
                         selectedUnits = selectedUnits.filter(u => u !== hitUnit);
                         hitUnit.selectRing.visible = false;
                    }
                    return;
                } else {
                    // Enemy Unit Clicked -> Attack Target
                    if(selectedUnits.length > 0) {
                        selectedUnits.forEach(u => {
                            if(!u.isShaman) { // Shaman might need spell to attack, or can auto attack?
                                u.attackTarget = hitUnit;
                                u.state = 'combat';
                            }
                        });
                        spawnPulse(hitUnit.mesh.position.x, hitUnit.mesh.position.y, hitUnit.mesh.position.z, 0xFF0000);
                        return;
                    }
                }
            }
        }

        // 2. Terrain Click
        const meshes = [];
        for(let k in chunks) meshes.push(chunks[k].children[0]);
        const hits = raycaster.intersectObjects(meshes);
        if(hits.length > 0) {
             const pt = hits[0].point;
             // If we are in 'move' mode and have units selected, move them
             if(currentAction === 'move' && selectedUnits.length > 0) {
                 selectedUnits.forEach(u => {
                     u.goto(pt.x, pt.z);
                     u.attackTarget = null;
                 });
                 spawnPulse(pt.x, getHeight(pt.x, pt.z), pt.z, 0xFFFFFF);
             } else {
                 performAction(pt.x, pt.z);
             }
        }
    }
    function onWheel(e) { viewScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewScale + e.deltaY * 0.05)); updateCameraZoom(); updateCameraPosition(); }
    function updateCameraZoom() { const aspect = window.innerWidth / window.innerHeight; camera.left = -viewScale*aspect; camera.right = viewScale*aspect; camera.top = viewScale; camera.bottom = -viewScale; camera.updateProjectionMatrix(); }
    function updateCameraPosition() { const offsetX = 30; const offsetZ = 30; const targetX = cameraLookAt.x + offsetX; const targetZ = cameraLookAt.z + offsetZ; let targetY = 25 + (viewScale / MAX_ZOOM) * 35; const groundUnderCamera = getHeight(targetX, targetZ); if(targetY < groundUnderCamera + 5) { targetY = groundUnderCamera + 5; } camera.position.set(targetX, targetY, targetZ); camera.lookAt(cameraLookAt); }
    function onResize() { updateCameraZoom(); renderer.setSize(window.innerWidth, window.innerHeight); }

    function animate() {
        requestAnimationFrame(animate); const dt = Math.min(clock.getDelta(), 0.1);
        // Mana Regeneration linked to population
        const playerBraves = units.filter(u => u.faction === 0 && u.type === 'wild').length;
        const manaRate = 1.0 + (playerBraves * 0.2); // Base + bonus per brave

        if(mana < 100) { mana += dt * manaRate; updateUI(); }
        updateChunks();
        enemyAI.update(dt);
        units.forEach(u => u.update(dt));
        buildings.forEach(b => b.update(dt));
        
        // Remove dead
        for(let i = buildings.length-1; i>=0; i--) { if(buildings[i].dead) buildings.splice(i, 1); }

        for(let i = projectiles.length-1; i>=0; i--) { if(!projectiles[i].update(dt)) projectiles.splice(i, 1); }
        for(let i = particles.length-1; i>=0; i--) { if(!particles[i].update(dt)) particles.splice(i, 1); }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>


